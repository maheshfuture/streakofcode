date==14-05-23
Given an array A of size N. Find the maximum subset-sum of elements that you can make from the given array such that for every two consecutive elements in the array, at least one of the elements is present in our subset. 

Example 1:

Input: 
N = 4
A[] = {1, -1, 3, 4}
Output: 8
Explanation: 
We can choose 0th,2nd & 3rd index(0 based 
Index),so that it can satisfy the 
condition & can make maximum sum 8. 
Example 2:

Input: 
N = 3
A[] =  {0, 2, 0};
Output: 2
Explanation: 
We can choose 1st index. Here the 
maximum possible sum is 2.
Your task:

You don't have to read input or print anything. Your task is to complete the function findMaxSubsetSum() which takes the array A and its size N as input and returns the Maximum possible subset-sum.

Expected Time Complexity: O(N)
Expected Auxiliary Space: O(N)
Solution:-
class Solution {

  public:
    long long findMaxSubsetSum(int N, vector<int> &A) {
        // code here
        long long a = A[0],b = A[1] + max(0,A[0]);
        for(long long c,i=2;i<N;i++)
            c = max(a,b) + A[i],a = b,b = c;
        return max(a,b);
    }
};
day3 15-05-23
Count Total Setbits
You are given a number N. Find the total number of setbits in the numbers from 1 to N. 

Example 1:

Input: N = 3
Output: 4
Explaination: 
1 -> 01, 2 -> 10 and 3 -> 11. 
So total 4 setbits.
Example 2:

Input: N = 4
Output: 5
Explaination: 1 -> 01, 2 -> 10, 3 -> 11 
and 4 -> 100. So total 5 setbits.
Your Task:
You do not need to read input or print anything. Your task is to complete the function countBits() which takes N as input parameter and returns the total number of setbits upto N.

Expected Time Complexity: O(1)
Expected Auxiliary Space: O(1)
solution:-
class Solution {
  public:
    long long countBits(long long N) {
        // code here
       int ans=0;
        for(int i=1;i<=N;i++){
            ans+=__builtin_popcount(i);
        }
        return ans;
    }
};

//day 8-7-2023

Find triplets with zero sum
Given an array arr[] of n integers. Check whether it contains a triplet that sums up to zero. 

Note: Return 1, if there is at least one triplet following the condition else return 0.

Example 1:

Input: n = 5, arr[] = {0, -1, 2, -3, 1}
Output: 1
Explanation: 0, -1 and 1 forms a triplet
with sum equal to 0.
Example 2:

Input: n = 3, arr[] = {1, 2, 3}
Output: 0
Explanation: No triplet with zero sum exists. 

Your Task:
You don't need to read input or print anything. Your task is to complete the boolean function findTriplets() which takes the array arr[] and the size of the array (n) as inputs and print 1 if the function returns true else print 0 if the function returns false. 

Expected Time Complexity: O(n2)
Expected Auxiliary Space: O(1)

Constrains:
1 <= n <= 104
-106 <= Ai <= 106
solution--

class Solution{
  public:
    //Function to find triplets with zero sum.
    bool findTriplets(int arr[], int n)
    { 
        //Your code here
        sort(arr,arr+n);
        for(int i=0;i<n;i++){
            int a=arr[i];
            int low= i+1;
            int high=n-1;
            while(low<high){
                if(arr[low]+arr[high]+a == 0){
                    return 1;
                }
                else if(arr[low]+arr[high] < -a){
                    low++;
                }
                else{
                    high--;
                }
            }
        }
        return 0;
    }
};

9-7-2023
Smallest Positive missing number
You are given an array arr[] of N integers including 0. The task is to find the smallest positive number missing from the array.

Example 1:

Input:
N = 5
arr[] = {1,2,3,4,5}
Output: 6
Explanation: Smallest positive missing 
number is 6.
Example 2:

Input:
N = 5
arr[] = {0,-10,1,3,-20}
Output: 2
Explanation: Smallest positive missing 
number is 2.
solution--

class Solution
{
    public:
    //Function to find the smallest positive number missing from the array.
    int missingNumber(int arr[], int n) 
    { 
        // Your code here
        set <int> val;
        for(int i = 0 ; i  < n ; i++){
            if(arr[i] > 0){
               val.insert(arr[i]); 
            }
        }
        
        int ans = 1; 
        
        while(val.empty() == 0 && ans == (*(val.begin()))){
            val.erase(val.begin());
            ans++;
        }
        
        return ans ;

    } 
};

10-7-2023
Transpose of Matrix
Write a program to find the transpose of a square matrix of size N*N. Transpose of a matrix is obtained by changing rows to columns and columns to rows.

Example 1:

Input:
N = 4
mat[][] = {{1, 1, 1, 1},
           {2, 2, 2, 2}
           {3, 3, 3, 3}
           {4, 4, 4, 4}}
Output: 
{{1, 2, 3, 4},  
 {1, 2, 3, 4}  
 {1, 2, 3, 4}
 {1, 2, 3, 4}} 
Example 2:

Input:
N = 2
mat[][] = {{1, 2},
           {-9, -2}}
Output:
{{1, -9}, 
 {2, -2}}
solution--
class Solution
{   
    public:  
    //Function to find transpose of a matrix.
    void transpose(vector<vector<int> >& matrix, int n)
    { 
        // code here 
         for(int i = 0; i < n; i++){
            for(int j = i+1; j < n; j++){
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }
};

13-07023
Unique Number of Occurrences
Given an array arr of N integers, the task is to check whether the frequency of the elements in the array is unique or not. Or in other words, there are no two distinct numbers in array with equal frequency. If all the frequency is unique then return true, else return false.

Example 1:

Input:
N = 5
arr = [1, 1, 2, 5, 5]
Output:
false
Explanation:
The array contains 2 (1’s), 1 (2’s) and 2 (5’s), since the number of frequency of 1 and 5 are the same i.e. 2 times. Therefore, this array does not satisfy the condition.
Example 2:

Input:
N = 10
arr = [2, 2, 5, 10, 1, 2, 10, 5, 10, 2]
Output:
true
Explanation:
Number of 1’s -> 1
Number of 2’s -> 4
Number of 5’s -> 2
Number of 10’s -> 3.
Since, the number of occurrences of elements present in the array is unique. Therefore, this array satisfy the condition.

solution--
class Solution
{
    public:
    bool isFrequencyUnique(int n, int arr[])
    {
        
        unordered_map<int, int> mp;
        
        for(int i = 0 ; i < n;i++){
            mp[arr[i]]++;
            
        }
        
        vector<int> a;
        for(auto it : mp){
            int x = it.second;
            a.push_back(x);
            
        }
        
        int res = a .size();
        
        set<int> st;
        
        for(auto i : a){
            st.insert(i);
        }
        
        if(st.size() == res) return true;
        return false;
        
    }
};

Implement two stacks in an array
Your task is to implement  2 stacks in one array efficiently. You need to implement 4 methods.
push1 : pushes element into first stack.
push2 : pushes element into second stack.
pop1 : pops element from first stack and returns the popped element. If first stack is empty, it should return -1.
pop2 : pops element from second stack and returns the popped element. If second stack is empty, it should return -1.

Example 1:

Input:
push1(2)
push1(3)
push2(4)
pop1()
pop2()
pop2()
Output:
3 4 -1
Explanation:
push1(2) the stack1 will be {2}
push1(3) the stack1 will be {2,3}
push2(4) the stack2 will be {4}
pop1()   the poped element will be 3 from stack1 and stack1 will be {2}
pop2()   the poped element will be 4 from stack2 and now stack2 is empty
pop2()   the stack2 is now empty hence returned -1.
Example 2:

Input:
push1(1)
push2(2)
pop1()
push1(3)
pop1()
pop1()
Output:
3 1 -1
Explanation:
push1(1) the stack1 will be {1}
push2(2) the stack2 will be {2}
pop1()   the poped element will be 1 from stack1 and stack1 will be empty
push1(3) the stack1 will be {3}
pop1()   the poped element will be 3 from stack1 and stack1 will be empty
pop1()   the stack1 is now empty hence returned -1.

solution--
class twoStacks
{
    int *arr;
    int size;
    int top1, top2;
    public:
    
    twoStacks(int n=100)
    {
        size = n; 
        arr = new int[n]; 
        top1 = -1; 
        top2 = size;
    }
 
    //Function to push an integer into the stack1.
    void push1(int x)
    {
        if(top1!=size && top1!=top2){
            arr[++top1] = x;
        }
    }
    
    //Function to push an integer into the stack2.
    void push2(int x)
    {
       if(top2!= 0 && top2 != top1){
           arr[--top2] = x;
       }
    }
    
    //Function to remove an element from top of the stack1.
    int pop1()
    {
        if(top1 == -1){
            return -1;
        }
        else{
            int n = arr[top1--];
            return n;
        }
        
    }
    
    //Function to remove an element from top of the stack2.
    int pop2()
    {
       if(top2 == size){
           return -1;
       }
       else{
           int x = arr[top2++];
           return x;
       }
    }
};

Min Operations
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
You are given two numbers, n and m. Your task is to transform n into m using the minimum number of operations. There are two operations available: either add 2 to n or add 1 to n in a single operation.
Input
The first line of input contains two space-separated integers n and m.

Constraints:-
1 ≤ n ≤ m ≤ 1000
Output
Print the minimum number of operations.
Example
Sample Input 1:
8 10

Sample Output 1:
1

Explanation 1:
Only 1 operation of adding 2 to n is needed.

solution--
#include <iostream>
#include <cmath>
using namespace std;
int minOperations(int n, int m) {
    int operations = 0;

    if (n == m) {
        return operations;
    }

    if (n < m) {
        int diff = m - n;
        if (diff == 1) {
            n += 1;
            operations += 1;
        } else {
            operations += ceil(static_cast<double>(diff) / 2);
            n += 2 * (diff / 2);
        }
    }

    if (n > m) {
        return -1;
    }

    return operations;
}

int main() {
    int n, m;
    cin >> n >> m;

    cout << minOperations(n, m) <<endl;

    return 0;
}

Queue Reversal
Given a Queue Q containing N elements. The task is to reverse the Queue. Your task is to complete the function rev(), that reverses the N elements of the queue.

Example 1:

Input:
6
4 3 1 10 2 6
Output: 
6 2 10 1 3 4
Explanation: 
After reversing the given elements of the queue , the resultant queue will be 6 2 10 1 3 4.
Example 2:

Input:
4
4 3 2 1 
Output: 
1 2 3 4
Explanation: 
After reversing the given elements of the queue , the resultant queue will be 1 2 3 4.
Your Task: You need to complete the function rev that takes a queue as parameter and returns the reversed queue. The printing is done automatically by the driver code.

Expected Time Complexity : O(n)
Expected Auxilliary Space : O(n)

solution--
class Solution
{
    public:
    queue<int> rev(queue<int> q)
    {
        // add code here.
        vector<int>ans;
        queue<int>anss;
        
        while(!q.empty())
        {
            ans.push_back(q.front());
            q.pop();
        }
        reverse(ans.begin(),ans.end());
       for(auto it:ans)
       {
           anss.push(it);
       }
       return anss;
    }
};

First non-repeating character in a stream
Given an input stream A of n characters consisting only of lower case alphabets. While reading characters from the stream, you have to tell which character has appeared only once in the stream upto that point. If there are many characters that have appeared only once, you have to tell which one of them was the first one to appear. If there is no such character then append '#' to the answer.
 

Example 1:

Input: A = "aabc"
Output: "a#bb"
Explanation: For every character first non
repeating character is as follow-
"a" - first non-repeating character is 'a'
"aa" - no non-repeating character so '#'
"aab" - first non-repeating character is 'b'
"aabc" - first non-repeating character is 'b'
Example 2:

Input: A = "zz"
Output: "z#"
Explanation: For every character first non
repeating character is as follow-
"z" - first non-repeating character is 'z'
"zz" - no non-repeating character so '#'

solution--
class Solution {
	public:
		string FirstNonRepeating(string A){
		    // Code here
		    unordered_map<char,int>mp;
		    queue<char>q;
		    string ans="";
		    for(int i=0;i<A.size();i++){
		        mp[A[i]]++;
		        if(mp[A[i]]==1){
		            q.push(A[i]);
		        }
		        while(mp[q.front()]>1 && q.size()){
		            q.pop();
		        }
		        if(q.size()!=0)
		        ans.push_back(q.front());
		        else{
		            ans.push_back('#');
		        }
		    }
		    return ans;
		}

};

Non Repeating Character--
Given a string S consisting of lowercase Latin Letters. Return the first non-repeating character in S. If there is no non-repeating character, return '$'.

Example 1:

Input:
S = hello
Output: h
Explanation: In the given string, the
first character which is non-repeating
is h, as it appears first and there is
no other 'h' in the string.
Example 2:

Input:
S = zxvczbtxyzvy
Output: c
Explanation: In the given string, 'c' is
the character which is non-repeating. 

solution--
class Solution
{
    public:
    //Function to find the first non-repeating character in a string.
    char nonrepeatingCharacter(string s)
    {
       //Your code here
       unordered_map<char,int>mp;
       for(int i=0;i<s.length();i++){
           mp[s[i]]++;
       }
       for(int i=0;i<s.length();i++){
           if(mp[s[i]]==1){
               return s[i];
           }
       }
       return '$';
       
    }

};


Given a linked list of 0s, 1s and 2s, sort it.
Given a linked list of N nodes where nodes can contain values 0s, 1s, and 2s only. The task is to segregate 0s, 1s, and 2s linked list such that all zeros segregate to head side, 2s at the end of the linked list, and 1s in the mid of 0s and 2s.

Example 1:

Input:
N = 8
value[] = {1,2,2,1,2,0,2,2}
Output: 0 1 1 2 2 2 2 2
Explanation: All the 0s are segregated
to the left end of the linked list,
2s to the right end of the list, and
1s in between.
Example 2:

Input:
N = 4
value[] = {2,2,0,1}
Output: 0 1 2 2
Explanation: After arranging all the
0s,1s and 2s in the given format,
the output will be 0 1 2 2.
Your Task:
The task is to complete the function segregate() which segregates the nodes in the linked list as asked in the problem statement and returns the head of the modified linked list. The printing is done automatically by the driver code.

Expected Time Complexity: O(N).
Expected Auxiliary Space: O(N).

Constraints:
1 <= N <= 106

solution--
/*    
  Node is defined as
  struct Node {
    int data;
    struct Node *next;
    Node(int x) {
        data = x;
        next = NULL;
    }
};

*/
class Solution
{
    public:
    //Function to sort a linked list of 0s, 1s and 2s.
         Node* segregate(Node *head) {
        
        
         int zero=0;
    int one=0;
    int two=0;
    Node* curr=head;
    while(curr!=NULL)
    {
        if(curr->data==0)
        zero++;
        else if(curr->data==1)
        one++;
        else
        two++;
        curr=curr->next;
    }
    
    curr=head;
  
       while(zero--)
       {
           curr->data=0;
           curr=curr->next;
       }
       while(one--)
       {
           curr->data=1;
           curr=curr->next;
       }
       while(two--)
       {
           curr->data=2;
           curr=curr->next;
       }
       return head;
        
    }
};

Level order traversal in spiral form
EasyAccuracy: 36.43%Submissions: 182K+Points: 2
POTD July Placement Special : All POTD in the month of July are based on popular interview questions. Solve every day to ace the upcoming Placement Season !
Given a binary tree and the task is to find the spiral order traversal of the tree.

Spiral order Traversal mean: Starting from level 0 for root node, for all the even levels we print the node's value from right to left and for all the odd levels we print the node's value from left to right. 

For below tree, function should return 1, 2, 3, 4, 5, 6, 7.


 
 

Example 1:

Input:
      1
    /   \
   3     2
Output:1 3 2

Example 2:

Input:
           10
         /     \
        20     30
      /    \
    40     60
Output: 10 20 30 60 40 
Your Task:
The task is to complete the function findSpiral() which takes root node as input parameter and returns the elements in spiral form of level order traversal as a list. The newline is automatically appended by the driver code.
Expected Time Complexity: O(N).
Expected Auxiliary Space: O(N).

Constraints:
1 <= Number of nodes <= 105
0 <= Data of a node <= 105

solution--
vector<int> findSpiral(Node *root)
{
    //Your code here
    if(root==NULL)return{};
    vector<int>ans;
    queue<Node*>q;
    q.push(root);
    int k=1;
    while(!q.empty())
    {  int size=q.size();
    vector<int>temp;
        
        while(size--)
        {   Node *tem=q.front();
        q.pop();
        temp.push_back(tem->data);
           if(tem->left!=NULL)q.push(tem->left);
           if(tem->right!=NULL)q.push(tem->right);
           
        }
        if(k==0)
        {
            for(auto it:temp)ans.push_back(it);
            k=1;
        }
        else
        {
            reverse(temp.begin(),temp.end());
            for(auto it: temp)ans.push_back(it);
            k=0;
        }
        
    }
    return ans;
}

Kth Ancestor in a Tree
Given a binary tree of size  N, a node, and a positive integer k., Your task is to complete the function kthAncestor(), the function should return the kth ancestor of the given node in the binary tree. If there does not exist any such ancestor then return -1.
Note: It is guaranteed that the node exists in the tree.

Example 1:



Input:
K = 2 Node = 4
Output: 1
Explanation:
Since, K is 2 and node is 4, so we
first need to locate the node and
look k times its ancestors.
Here in this Case node 4 has 1 as his
2nd Ancestor aka the Root of the tree.
Example 2:

Input:
k=1 
node=3
      1
    /   \
    2     3

Output:
1
Explanation:
K=1 and node=3 ,Kth ancestor of node 3 is 1.
Your Task:
You are asked to complete the function kthAncestor() which accepts root of the tree, k and node as input parameters, and returns the kth ancestor of Node which contains node as its value.

Expected Time Complexity: O(N)
Expected Auxiliary Space: O(N)

Constraints:
1<=N<=105
1<= K <= 100
1 <= Node.data <= N

solution--
void traverse(Node *root, int parent, map<int,int> &m){
    if (root){
        m[root->data]=parent;
        traverse(root->left,root->data, m);
        traverse(root->right,root->data, m);
    }
}
// your task is to complete this function
int kthAncestor(Node *root, int k, int node)
{
    map<int,int> m;
    traverse(root, -1,m);
    int ans=-1;
    while (k--){
        ans=m[node];
        node=m[node];
        if (ans<0) return -1;
    }
    return ans;
    
}

Heap Sort
Given an array of size N. The task is to sort the array elements by completing functions heapify() and buildHeap() which are used to implement Heap Sort.

Example 1:

Input:
N = 5
arr[] = {4,1,3,9,7}
Output:
1 3 4 7 9
Explanation:
After sorting elements
using heap sort, elements will be
in order as 1,3,4,7,9.
Example 2:

Input:
N = 10
arr[] = {10,9,8,7,6,5,4,3,2,1}
Output:
1 2 3 4 5 6 7 8 9 10
Explanation:
After sorting elements
using heap sort, elements will be
in order as 1, 2,3,4,5,6,7,8,9,10.
Your Task :
You don't have to read input or print anything. Your task is to complete the functions heapify(), buildheap() and heapSort() where heapSort() and buildheap() takes the array and it's size as input and heapify() takes the array, it's size and an index i as input. Complete and use these functions to sort the array using heap sort algorithm.
Note: You don't have to return the sorted list. You need to sort the array "arr" in place.

Expected Time Complexity: O(N * Log(N)).
Expected Auxiliary Space: O(1).

Constraints:
1 ≤ N ≤ 106
1 ≤ arr[i] ≤ 106

solution--
class Solution
{
    public:
    //Heapify function to maintain heap property.
       void heapify(int arr[], int n, int i)  
    {
      // Your Code Here
      int lar = i;
      int l =2*i+1, r= 2*i+2;
      if(l<n && arr[l]>arr[lar])
            lar = l;
        if(r<n && arr[r]>arr[lar])
             lar = r;
        if(lar!= i){
            swap(arr[i], arr[lar]);
            heapify(arr,n,lar);
        }
    }

    public:
    //Function to build a Heap from array.
    void buildHeap(int arr[], int n)  
    { 
    // Your Code Here
    for(int i = (n-2)/2; i>=0;i--)
        heapify(arr,n,i);
    }

    
    public:
    //Function to sort an array using Heap Sort.
    void heapSort(int arr[], int n)
    {
        //code here
        buildHeap(arr,n);
        for(int i=n-1;i>=1;i--){
            swap(arr[0],arr[i]);
            heapify(arr,i,0);
        }
    }
};

Inorder Successor in BST
Given a BST, and a reference to a Node x in the BST. Find the Inorder Successor of the given node in the BST.
 

Example 1:

Input:
      2
    /   \
   1     3
K(data of x) = 2
Output: 3 
Explanation: 
Inorder traversal : 1 2 3 
Hence, inorder successor of 2 is 3.

Example 2:

Input:
             20
            /   \
           8     22
          / \
         4   12
            /  \
           10   14
K(data of x) = 8
Output: 10
Explanation:
Inorder traversal: 4 8 10 12 14 20 22
Hence, successor of 8 is 10.
 

Your Task:
You don't need to read input or print anything. Your task is to complete the function inOrderSuccessor(). This function takes the root node and the reference node as argument and returns the node that is inOrder successor of the reference node. If there is no successor, return null value.


Expected Time Complexity: O(Height of the BST).
Expected Auxiliary Space: O(1).


solution--

class Solution{
    vector<Node*> ans;
  private:
    void inorder(Node*root){
        if(!root) return;
        inorder(root->left);
        ans.push_back(root);
        inorder(root->right);
    }
  public:
    // returns the inorder successor of the Node x in BST (rooted at 'root')
    Node * inOrderSuccessor(Node *root, Node *x)
    {
        //Your code here
        
        if(!root || ! x) return nullptr;
        inorder(root);
        for(size_t i =0;i<ans.size()-1;i++){
            if(ans[i]== x) return ans[i+1];
        }
        return NULL;
    }
};

DFS of Graph
You are given a connected undirected graph. Perform a Depth First Traversal of the graph.
Note: Use a recursive approach to find the DFS traversal of the graph starting from the 0th vertex from left to right according to the graph.


Example 1:

Input: V = 5 , adj = [[2,3,1] , [0], [0,4], [0], [2]]

Output: 0 2 4 3 1
Explanation: 
0 is connected to 2, 3, 1.
1 is connected to 0.
2 is connected to 0 and 4.
3 is connected to 0.
4 is connected to 2.
so starting from 0, it will go to 2 then 4,
and then 3 and 1.
Thus dfs will be 0 2 4 3 1.
Example 2:

Input: V = 4, adj = [[1,3], [2,0], [1], [0]]

Output: 0 1 2 3
Explanation:
0 is connected to 1 , 3.
1 is connected to 0, 2. 
2 is connected to 1.
3 is connected to 0. 
so starting from 0, it will go to 1 then 2
then back to 0 then 0 to 3
thus dfs will be 0 1 2 3. 

Your task:
You don't need to read input or print anything. Your task is to complete the function dfsOfGraph() which takes the integer V denoting the number of vertices and adjacency list as input parameters and returns a list containing the DFS traversal of the graph starting from the 0th vertex from left to right according to the graph.


Expected Time Complexity: O(V + E)
Expected Auxiliary Space: O(V)


Constraints:
1 ≤ V, E ≤ 104

solution--

class Solution {
  public:
    // Function to return a list containing the DFS traversal of the graph.
    vector<int>ans;
    void solve(vector<int>adj[],vector<int>&vis,int start){
        for(auto it:adj[start]){
            if(vis[it]==0){
                // cout<<it<<" ";
                vis[it]=1;
                ans.push_back(it);
                solve(adj,vis,it);
            }
        }
    }
    vector<int> dfsOfGraph(int V, vector<int> adj[]) {
        // Code here
        vector<int>vis(V,0);
        ans.push_back(0);
        vis[0]=1;
        solve(adj,vis,0);
        return ans;
    }
};
Fraction pairs with sum 1
Given a list of N fractions, represented as two lists numerator and denominator, the task is to determine the count of pairs of fractions whose sum equals 1.

Example 1:

Input:
N = 4
numerator = [1, 2, 2, 8]
denominator = [2, 4, 6, 12]
Output:
2
Explanation:
Fractions 1/2 and 2/4 sum to 1. Similarly fractions 2/6 and 8/12 sum to 1. So there are 2 pairs of fractions which sum to 1.
Example 2:

Input:
N = 5
numerator = [3, 1, 12, 81, 2]
denominator = [9, 10, 18, 90, 5]
Output:
2
Explanation:
Fractions 3/9 and 12/18 sum to 1. Similarly fractions 1/10 and 81/90 sum to 1. So there are 2 pairs of fractions which sum to 1.
Your task:
You don't need to read input or print anything. Your task is to complete the function countFractions() which take integer N and arrays numerator and denominator of size N as arguments, and returns an integer.

Expected Time Complexity: O(N*log(N))
Expected Auxiliary Space: O(N)

Constraints:
1 <= N <=105
1 <= numerator[i] <= denominator[i] <= 109

int countFractions(int n, int num[], int den[])
    {
        unordered_map<double, int> mp;
        int count = 0;
        
        for(int i = 0; i < n; i++) {
            int gcd = __gcd(num[i], den[i]);
            
            double nm = num[i] / gcd;
            double dm = den[i] / gcd;
            
            double x = (dm - nm) / dm;
            double y = (nm / dm);
            
            if(mp[x] > 0)
                count = count + mp[x];
                
            mp[y]++;
        }
        
        return count;
}
Largest prime factor
Given a number N, the task is to find the largest prime factor of that number.
 Example 1:

Input:
N = 5
Output:
5
Explanation:
5 has 1 prime factor i.e 5 only.
Example 2:

Input:
N = 24
Output:
3
Explanation:
24 has 2 prime factors 2 and 3 in which 3 is greater.
Your Task:
You don't need to read input or print anything. Your task is to complete the function largestPrimeFactor() which takes an integer N as input parameters and returns an integer, largest prime factor of N.

Expected Time Complexity: O(sqrt(N))
Expected Space Complexity: O(1)

Constraints:
2 <= N <= 109

 int ans = -1;
        while(n%2==0)
        {
            ans = max(ans,2);
            n = n/2;
        }
        for(int i = 3;i<=sqrt(n);i=i+2)
        {
            while(n%i==0)
            {
                ans = max(ans,i);
                n = n/i;
            }
        }
        if (n > 2)
       {
           ans = max(ans,n);
       }
       return ans;


Longest Common Subsequence
Given two strings, find the length of longest subsequence present in both of them. Both the strings are in uppercase latin alphabets.

Example 1:

Input:
A = 6, B = 6
str1 = ABCDGH
str2 = AEDFHR
Output: 3
Explanation: LCS for input strings “ABCDGH” and “AEDFHR” is “ADH” of length 3.
Example 2:

Input:
A = 3, B = 2
str1 = ABC
str2 = AC
Output: 2
Explanation: LCS of "ABC" and "AC" is "AC" of length 2.
Your Task:
Complete the function lcs() which takes the length of two strings respectively and two strings as input parameters and returns the length of the longest subsequence present in both of them.

Expected Time Complexity : O(|str1|*|str2|)
Expected Auxiliary Space: O(|str1|*|str2|)

Constraints:
1<=size(str1),size(str2)<=103

class Solution
{
    public:
    //Function to find the length of longest common subsequence in two strings.
    int solve(string &s1,string &s2,int n,int m, vector<vector<int>>&dp){
        if(dp[n][m]!=-1){
            return dp[n][m];
        }
        if(n==0 || m==0){
            return 0;
        }
        if(s1[n-1]==s2[m-1]){
            return dp[n][m]=1+solve(s1,s2,n-1,m-1,dp);
        }
        return dp[n][m]=max(solve(s1,s2,n-1,m,dp),solve(s1,s2,n,m-1,dp));
    }
    int lcs(int n, int m, string s1, string s2)
    {
        // your code here
        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));
        return solve(s1,s2,n,m,dp);
    }
};


Longest Increasing Subsequence
Given an array of integers, find the length of the longest (strictly) increasing subsequence from the given array.

Example 1:

Input:
N = 16
A = {0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15}
Output: 
6
Explanation:
There are more than one LIS in this array. One such Longest increasing subsequence is {0,2,6,9,13,15}.
Example 2:

Input:
N = 6
A[] = {5,8,3,7,9,1}
Output: 
3
Explanation:
There are more than one LIS in this array.  One such Longest increasing subsequence is {5,7,9}.
Your Task:
Complete the function longestSubsequence() which takes the input array and its size as input parameters and returns the length of the longest increasing subsequence.

Expected Time Complexity : O( N*log(N) )
Expected Auxiliary Space: O(N)

Constraints:
1 ≤ N ≤ 104
0 ≤ A[i] ≤ 106

class Solution
{
    public:
    //Function to find length of longest increasing subsequence.
     int longestSubsequence(int n, int a[])
    {
       // your code here
    vector<int> temp;
    temp.push_back(a[0]);
    int len = 1;
    
    for(int i =1; i< n; i++){
        if(a[i] > temp.back()){
            temp.push_back(a[i]);
            len++;
        }
        else{
            int ind = lower_bound(temp.begin(), temp.end(), a[i]) - temp.begin();
            temp[ind] = a[i];
        }
        
    }
    return len;
    }
};
Given a positive integer n, find the nth fibonacci number. Since the answer can be very large, return the answer modulo 1000000007.

Example 1:

Input:


n = 2
Output: 
1 
Explanation: 
1 is the 2nd number of fibonacci series.
Example 2:

Input: 
n = 5
Output: 
5
Explanation: 
5 is the 5th number of fibonacci series.
Your Task:  
You dont need to read input or print anything. Complete the function nthFibonacci() which takes n as input parameter and returns nth fibonacci number.

Expected Time Complexity: O(n)
Expected Auxiliary Space: O(n)

Constraints:
1<= n <=105
Nth Fibonacci Number

class Solution {
  public:
//   int F(int n){
//       if (n <= 1)
//       {
//         return n;
//       }
       
//     return F(n-1) + F(n-2);
//   }
    int nthFibonacci(int n){
        // code here
    //   int a = 0, b = 1, c, i;
    // if( N == 0)
    //     return a;
    // for(i = 2; i <= N; i++)
    // {
    //   c = a + b;
    //   a = b;
    //   b = c;
    // }
    // return b;
    const long long MOD = 1000000007;
        
     
        if (n == 0) return 0;
        if (n == 1) return 1;
    
        long long a = 0, b = 1;
    
        for (int i = 2; i <= n; ++i) {
            long long next = (a + b) % MOD;
            a = b;
            b = next;
        }
    
        return b;
    }
};

Non Repeating Numbers
Given an array A containing 2*N+2 positive numbers, out of which 2*N numbers exist in pairs whereas the other two number occur exactly once and are distinct. Find the other two numbers. Return in increasing order.

Example 1:

Input: 
N = 2
arr[] = {1, 2, 3, 2, 1, 4}
Output:
3 4 
Explanation:
3 and 4 occur exactly once.
Example 2:

Input:
N = 1
arr[] = {2, 1, 3, 2}
Output:
1 3
Explanation:
1 3 occur exactly once.
Your Task:
You do not need to read or print anything. Your task is to complete the function singleNumber() which takes the array as input parameter and returns a list of two numbers which occur exactly once in the array. The list must be in ascending order.

Expected Time Complexity: O(N)
Expected Space Complexity: O(1)

Constraints:
1 <= length of array <= 106 
1 <= Elements in array <= 5 * 106

class Solution
{
public:
    vector<int> singleNumber(vector<int> nums) 
    {
        int n=nums.size();
        vector<int> v;
       sort(nums.begin(),nums.end());
       for(int i=0;i<n;i++){
           if(nums[i]==nums[i+1]) ++i;
           else v.push_back(nums[i]);
       }
       return v;
    }
};

Flip Bits
Given an array A[] consisting of 0’s and 1’s. A flip operation is one in which you turn 1 into 0 and a 0 into 1. You have to do at most one “Flip” operation of any subarray. Formally, select a range (l, r) in the array A[], such that (0 ≤ l ≤ r < n) holds and flip the elements in this range to get the maximum ones in the final array. You can possibly make zero operations to get the answer.

Example 1:

Input:
N = 5
A[] = {1, 0, 0, 1, 0} 
Output:
4
Explanation:
We can perform a flip operation in the range [1,2]
After flip operation array is : [ 1 1 1 1 0 ]
Count of one after fliping is : 4
[Note: the subarray marked in bold is the flipped subarray]
Example 2:

Input:
N = 7
A[] = {1, 0, 0, 1, 0, 0, 1}
Output:
6
Explanation:
We can perform a flip operation in the range [1,5]
After flip operation array is : [ 1 1 1 0 1 1 1]
Count of one after fliping is : 6
[Note: the subarray marked in bold is the flipped subarray]
Your Task:  
You don't need to read input or print anything. Your task is to complete the function maxOnes() which takes the array A[] and its size N as inputs and returns the maximum number of 1's you can have in the array after atmost one flip operation.

Expected Time Complexity: O(N)
Expected Auxiliary Space: O(1)

Constraints:
1 ≤ N ≤ 106
0 ≤ A[i] ≤ 1

class Solution{
    public:
    int maxOnes(int a[], int n)
    {
        // Your code goes here
        int ans=0;
        int sum=0;
        for(int i=0;i<n;i++){
            if(a[i]==0){
                sum+=1;
            }
            else{
                sum-=1;
            }
            ans=max(ans,sum);
            if(sum<0){
                sum=0;
            }
        }
        int res=0;
        for(int i=0;i<n;i++){
            if(a[i]==1) res++; 
        }
        return res+ans;
    }
};

Nth catalan number
Given a number N. The task is to find the Nth catalan number.
The first few Catalan numbers for N = 0, 1, 2, 3, … are 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, …

Catalan Number for N is equal to the number of expressions containing N pairs of paranthesis that are correct matched, i.e., for each of the N '(' there exist N ')' on there right and vice versa.

Since answer can be huge return answer modulo 1e9+7.

Note: Positions start from 0 as shown above.

Example 1:

Input:
N = 5
Output: 42
Example 2:

Input:
N = 4
Output: 14

 int findCatalan(int n) 
    {
        //code here
        vector<long long int> v(n+1);
        int mod=1000000007;
        v[0]=1;
        v[1]=1;
        
        for(int i=2 ; i<=n; i++){
            v[i]=0;
            for(int j=0; j<i; j++){
                v[i]=(v[i]+v[j]*v[i-j-1])%mod;
            }
        }
        return v[n];
    }

Next Smallest Palindrome
Given a number, in the form of an array Num[] of size N containing digits from 1 to 9(inclusive). The task is to find the next smallest palindrome strictly larger than the given number.

Example 1:

Input:
N = 11
Num[] = {9, 4, 1, 8, 7, 9, 7, 8, 3, 2, 2}
Output: 9 4 1 8 8 0 8 8 1 4 9
Explanation: Next smallest palindrome is
94188088149.
Example 2:

Input:
N = 5
Num[] = {2, 3, 5, 4, 5}
Output: 2 3 6 3 2
Explanation: Next smallest palindrome is
23632.
Your Task:
Complete the function generateNextPalindrome() which takes an array num, and an single integer n, as input parameters and returns an array of integers denoting the answer. You don't to print answer or take inputs.

Expected Time Complexity: O(N)
Expected Auxiliary Space: O(1)

Constraints:
1 <= N <= 105
1 <= Num[i] <= 9

class Solution{
public:
 
 
bool ispalindrome(vector<int>a ,int s,int e)
{
    while(s<=e)
    {
        if(a[s]!=a[e])
        return false;
        s++;
        e--;
    }
}
 
void addone(vector<int>&a,int e)
{
    int carry=1;
    
    while(carry && (e+1))
    {
       int sum=a[e]+carry;
        carry=sum/10;
        sum=sum%10;
        a[e]=sum;
        e--;
    }
   if (carry > 0)
   {
            a.push_back(carry);
            reverse(a.begin(), a.end());
    }
}
vector<int> generateNextPalindrome(int num[], int n) 
{
   bool b=false;
   vector<int>v;
 
   for (int i = 0; i <n; i++)
        {
            v.push_back(num[i]);
        }
        
        if(ispalindrome(v,0,v.size()-1))
        {
            addone(v,v.size()-1);
        }
        
        while(!b)
        {
           int s=0,e=v.size()-1;
           while(s<=e)
          {
            while(v[s]!=v[e])
             {
               if(v[s]>v[e])
               v[e]=v[s];
               else
               {
                   v[e]=v[s];
                   addone(v,e-1);
               }
            }
            s++;
            e--;
          }
          b=ispalindrome(v,0,v.size()-1);
        }
        return v;
}
 
};

Subarray with given sum

Given an unsorted array A of size N that contains only positive integers, find a continuous sub-array that adds to a given number S and return the left and right index(1-based indexing) of that subarray.

In case of multiple subarrays, return the subarray indexes which come first on moving from left to right.

Note:- You have to return an ArrayList consisting of two elements left and right. In case no such subarray exists return an array consisting of element -1.

Example 1:

Input:
N = 5, S = 12
A[] = {1,2,3,7,5}
Output: 2 4
Explanation: The sum of elements 
from 2nd position to 4th position 
is 12.
Example 2:

Input:
N = 10, S = 15
A[] = {1,2,3,4,5,6,7,8,9,10}
Output: 1 5
Explanation: The sum of elements 
from 1st position to 5th position
is 15.
Your Task:
You don't need to read input or print anything. The task is to complete the function subarraySum() which takes arr, N, and S as input parameters and returns an ArrayList containing the starting and ending positions of the first such occurring subarray from the left where sum equals to S. The two indexes in the array should be according to 1-based indexing. If no such subarray is found, return an array consisting of only one element that is -1.

Expected Time Complexity: O(N)
Expected Auxiliary Space: O(1)

Constraints:
1 <= N <= 105
1 <= Ai <= 109
0<= S <= 109

class Solution
{
    public:
    //Function to find a continuous sub-array which adds up to a given number.
    vector<int> subarraySum(vector<int>arr, int n, long long s)
    {
        // Your code here
       vector<int> res;
        int i = 0,j = 0;
        int sum = 0;
        while(i<n){
            sum += arr[i++];
            while(sum>s){
                sum -= arr[j++];
            }
            if(sum==s && j<i){
                res.push_back(j+1);
                res.push_back(i);
                return res;
            }
        }
        if(res.empty()) res.push_back(-1);
        return res;
    }
};

Number of occurrenceclass Solution{

Given a sorted array Arr of size N and a number X, you need to find the number of occurrences of X in Arr.

Example 1:

Input:
N = 7, X = 2
Arr[] = {1, 1, 2, 2, 2, 2, 3}
Output: 4
Explanation: 2 occurs 4 times in the
given array.
Example 2:

Input:
N = 7, X = 4
Arr[] = {1, 1, 2, 2, 2, 2, 3}
Output: 0
Explanation: 4 is not present in the
given array.
Your Task:
You don't need to read input or print anything. Your task is to complete the function count() which takes the array of integers arr, n, and x as parameters and returns an integer denoting the answer.
If x is not present in the array (arr) then return 0.

Expected Time Complexity: O(logN)
Expected Auxiliary Space: O(1)

Constraints:
1 ≤ N ≤ 105
1 ≤ Arr[i] ≤ 106
1 ≤ X ≤ 106

class Solution{
public:	
	/* if x is present in arr[] then returns the count
		of occurrences of x, otherwise returns 0. */
	int count(int arr[], int n, int x) {
	    // code here
	   // unordered_map<int,int>freq;
	   // for(int i=0;i<n;i++){
	   //     freq(arr[i])++;
	   // }
	   // int count=0;
	   // for(auto x: freq){
	   // if(it.second ==1){
	   //     count++;
    //         }
	   // }
	   // return count;
	   int count=0;
	   for(int i=0;i<n;i++){
	       if(arr[i]==x) count++;
	   }
	   return count;
	}
	
};

Surround the 1's
Given a matrix of order nxm, composed of only 0's and 1's, find the number of 1's in the matrix that are surrounded by an even number (>0) of 0's. The surrounding of a cell in the matrix is defined as the elements above, below, on left, on right as well as the 4 diagonal elements around the cell of the matrix. Hence, the surrounding of any matrix elements is composed of 8 elements. Find the number of such 1's.

Example 1:

Input: 
matrix = {{1, 0, 0}, 
          {1, 1, 0}, 
          {0, 1, 0}}
Output: 
1
Explanation: 
1 that occurs in the 1st row and 1st column, has 3 surrounding elements 0,1 and 1. The occurrence of zero is odd. 
1 that occurs in 2nd row and 1st column has 5 surrounding elements 1,0,1,1 and 0. The occurrence of zero is even. 
1 that occurs in 2nd row and 2nd column has 8 surrounding elements. The occurrence of 0 is odd. 
Similarly, for the 1 that occurs in 3rd row and 2nd column, the occurrence of zero in it's 5 surrounding elements is odd. 
Hence, the output is 1.
Example 2:

Input: 
matrix = {{1}}
Output: 
0
Explanation: 
There is only 1 element in the matrix. Hence, it has no surroundings, so it's count for even 0's is 0 for the whole matrix. 
0 is even but we want occurrence of a zero in the surrounding at least once. 
Hence, output is 0.
        
