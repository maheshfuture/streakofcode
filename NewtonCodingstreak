day 1- 13-05-2023
question1-
Find X
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Let's consider a table consisting of n rows and n columns. The cell located at the intersection of i- th row and j- th column contains number i × j. The rows and columns are numbered starting from 1. You are given a positive integer x. Your task is to count the number of cells in a table that contain number x.
Input
The input consists of two space- separated integers n and x.

Constraints
1 ≤ n ≤ 105
1 ≤ x ≤ 109
Output
Print a single number: the number of times x occurs in the table.
Example
Sample Input 1
10 5
Sample Output 1
2

Sample Input 2
6 12
Sample Output 2
4
solution-
#include<bits/stdc++.h>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;

    int ans = 0;
    for(int i=1; i<=n; i++) {
        if(m % i == 0 && m/i <= n) {
            ans++;
        }
    }

    cout << ans << endl;
    return 0;
}
day2 14/05/23
King's Army Leaders
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
In a kingdom, there is a war going on between two armies led by two kings. Each king has an army of positive integers. Your task as a military advisor is to find the number of leaders of each army.

An element of the army is a leader if it is greater than or equal to all the soldiers on its right side. The rightmost soldier of each army is always a leader. The more the number of leaders more the chances of winning the war, predict the winner of the battle.
Input
The first line contains the size of the armies n1, n2.
The next line contains n1 space- separated integers for the army members of the first army.
The next line contains n2 space- separated integers for the army members of the second army.
Output
A single integer 1 if the first army wins else 2. They will never tie.
Example
Input:
6 6
1 3 2 5 7 3
1 2 3 8 7 6
Output :
2
Explanation:
First army contains 2 leaders(7, 3) and the second army contains 3 leaders (8, 7, 6) so we print 2.
solution:
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n1, n2;
    cin >> n1 >> n2;
    vector<int> a(n1), b(n2);
    for (int i = 0; i < n1; i++)
        cin >> a[i];
    for (int i = 0; i < n2; i++)
        cin >> b[i];
    int cnt1 = 0, cnt2 = 0;
    for (int i = 0; i < n1; i++) {
        bool leader = true;
        for (int j = i+1; j < n1; j++) {
            if (a[j] > a[i]) {
                leader = false;
                break;
            }
        }
        if (leader) cnt1++;
    }
    for (int i = 0; i < n2; i++) {
        bool leader = true;
        for (int j = i+1; j < n2; j++) {
            if (b[j] > b[i]) {
                leader = false;
                break;
            }
        }
        if (leader) cnt2++;
    }
    if (cnt1 > cnt2)
        cout << "1" << endl;
    else
        cout << "2" << endl;
    return 0;
}
day3 15-05-23
Gift Hunter
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Rahul is a gift lover he is currently located at {0, 0} in an n*m grid and the gift is located at {k, l}, given a string that contains characters {L, R, D, U}, the string represents path taken by Rahul, tell whether he will reach {k, l} at any point of time. L means left, R means right, U means up and D means down.
Assuming (x,y) is the initial point, here's how L,R, D, and U works in a grid:

L (Left): moves to (x-1, y)
R (Right): moves to (x+1, y)
D (Down): moves to (x, y-1)
U (Up): moves to (x, y+1)
Input
The first line contains two integers k, l the position of the gift.
The second line contains the string, path taken by Rahul.
0≤{k, l}≤105
2≤|s|≤103
Output
Output a single string "YES" or "NO".
Example
Input:
1 1
UR
Output :
YES
Explanation :
After U it moves to - > {0, 1} and then R moves to - >{1, 1}. So, we print YES.
solution:-
#include <iostream>
using namespace std;

bool willReachGift(int k, int l, string path) {
    int x = 0, y = 0; 
    for (char c : path) {
        if (c == 'L') {
            x--; // Move left
        } else if (c == 'R') {
            x++; // Move right
        } else if (c == 'D') {
            y--; // Move down
        } else if (c == 'U') {
            y++; // Move up
        }

        if (x == k && y == l) {
            return true;
        }
    }

    return false; 
}

int main() {
    int k, l;
    cin >> k >> l;
    string path;
    cin >> path;

    if (willReachGift(k, l, path)) {
        cout << "YES" << endl;
    } else {
        cout << "NO" << endl;
    }

    return 0;
}

8-7-2023
OddSum
Problem Statement
You are given a number N. You have to print "8" S times where S is the sum of odd digits in the number N.
It is guaranteed that there will be at least one odd digit in the number N.
Input
The first line of the input contains an integer N.

Constraints
1 ≤ N ≤ 109
Output
Print "8" the required number of times.
Example
Sample Input
423
Sample Output
888
Explanation
The sum of the odd digits = 3, therefore you have to print 8 thrice.

solution--
#include <iostream>
#include <string>

using namespace std;

void printEights(int n) {
    int sumOfOdds = 0;
    while (n > 0) {
        int digit = n % 10;
        if (digit % 2 != 0) {
            sumOfOdds += digit;
        }
        n /= 10;
    }

    string eights(sumOfOdds, '8');
    cout << eights << endl;
}

int main() {
    int n;
    cin >> n;

    printEights(n);

    return 0;
}

9-7-2023
Odd-Even Game
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Rahul and Abhilash are playing a game. They are given a number N at the beginning and both in their turn have to choose a number X such that
1 ≤ X ≤ N
If its Rahul's turn, X has to be even, but if its Abhilashs' turn, it has to be odd
After each turn, N becomes N - X. The player who is not able to choose any number in his turn loses. Find out who wins, if both play optimally and Rahul starts the game.
Input
The first line of the input contains a single integer N.

Constraints
1 ≤ N ≤ 109
Output
Print "Rahul" if he wins else print "Abhilash".
Example
Sample Input
2

Sample Output
Rahul

Explanation
Rahul chooses 2 and subtracts it from N. In Abhilashs' turn N is 0 and there is no odd positive integer less than 0, so he loses.

solution--
#include <iostream>
using namespace std;

int main() {
    int N;
    cin >> N;

    if (N % 2 == 0) {
        cout << "Rahul" << endl;
    } else {
        cout << "Abhilash" << endl;
    }

    return 0;
}

13-07-23
Odd Even product
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
You are given a positive number N. You have to print the product of the sum of odd digits and even digits in the number.
Input
The first line of the input contains an integer N.

Constraints
1 ≤ N ≤ 109
Output
Print the required product.
Example
Sample Input
241
Sample Output
6
Explanation
The sum of odd digits=1.
The sum of even digits = 2+4 = 6.
Product= 1*6 = 6.

solution--
#include <iostream>
using namespace std;
int oddEvenProduct(int n) {
    int oddSum = 0;
    int evenSum = 0;

    while (n > 0) {
        int digit = n % 10;
        if (digit % 2 == 0) {
            evenSum += digit;
        } else {
            oddSum += digit;
        }
        n /= 10;
    }

    return oddSum * evenSum;
}

int main() {
    int n;
    cin >> n;

    cout << oddEvenProduct(n) << endl;

    return 0;
}

16-07-2023
Count Different Bits
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Count the number of differing bits between two given numbers, n, and m.
Input
The first line of input contains two space-separated integers n and m.

Constraints:-
1 ≤ n, m ≤ 109
Output
Print the number of differing bits between two given numbers, n, and m.
Example
Sample Input 1:
3 7

Sample Output 1:
1

Explanation 1:
Binary representation of 3 = 011,
Binary representation of 7 = 111,
So, Only 1 bit is different in these numbers.

solution--
#include <bits/stdc++.h> 
using namespace std;

int countDifferingBits(int n, int m) {
    int xorResult = n ^ m;

    int differingBits = 0;
    while (xorResult > 0) {
        differingBits += xorResult & 1;
        xorResult >>= 1;
    }

    return differingBits;
}

int main() {
    int n, m;
    cin >> n >> m;

    int result = countDifferingBits(n, m);

    cout << result << std::endl;

    return 0;
}

Burger Distribution
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Abhilash buys N number of burgers and he wants to distribute all the N burgers among his 10 friends such that:
Each friend gets at least one burger
There is at least one case where No two friends get the same number of burgers

Check Whether Abhilash will be able to distribute or not according to the given rules.
Input
The only line contains an integer N.

Constraints
1 ≤ N ≤ 1000
Output
Print(without quotes) "yes" if Abhilash can divide the burgers according to the given rules, else print "no".
Example
Sample Input
18

Sample Output
no

Explanation
There is no case that Abhilash can distribute burgers by following the given rule.

solution--
#include <iostream>

using namespace std;

int main() {
    int N;
    cin >> N;

    if (N < 20 || N % 10 == 0 || N % 10 > 9) {
        cout << "no" << endl;
    } else {
        cout << "yes" << endl;
    }

    return 0;
}

20-7-23
Coin Distribution
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Rahul has n coins worth 1 rupee each, and he has m friends. He wants to distribute an equal number of coins to each of his friends. Determine whether it is possible for Rahul to distribute the coins equally among all his friends or not.
Input
The first line of input contains two space- separated integers n and m.

Constraints:-
1 ≤ n, m ≤ 1000
Output
Print true if it is possible for Rahul to distribute the coins equally among all his friends, otherwise false.
Example
Sample Input 1:
16 8

Sample Output 1:
true

Explanation 1:
Since he has the capability to distribute 2 coins to each of his friends, therefore true.

solution-
#include <iostream>
using namespace std;

bool canDistributeCoinsEqually(int n, int m) {
    return n % m == 0;
}

int main() {
    int n, m;
    cin >> n >> m;

    cout << (canDistributeCoinsEqually(n, m) ? "true" : "false") << endl;

    return 0;
}

23-07-23
Odd-sum
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
You are given three integers a, b, and c. Your task is to find out if you can choose two integers such that their sum is odd.
Input
The first line of the input contains three space-separated integers denoting a, b, and c
Constraints
1 ≤ a, b, c ≤ 100
Output
Print YES if you can choose two integers such that their sum is odd else print NO.
Example
Sample Input
70 25 26

Sample Output
YES

Explanation
You can choose 25 and 26.
25 + 26 = 51. (odd)

solution--
#include <iostream>
using namespace std;
string can_select_odd_sum(int a, int b, int c) {
    int combinations[3][2] = {{a, b}, {a, c}, {b, c}};

    for (int i = 0; i < 3; i++) {
        int x = combinations[i][0];
        int y = combinations[i][1];
        if ((x + y) % 2 != 0) { 
            return "YES";       
        }
    }

    return "NO";  
}

int main() {
  int n,m,r;
  cin>>n>>m>>r;
    cout << can_select_odd_sum(n, m, r) << endl;    

    return 0;
}

Frequency LCM
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Find the least common multiple (LCM) of the frequencies of all characters in a given string 's'.
Input
The first line of input contains string 's'.

Constraints:-
1 ≤ s. length ≤ 100
The string 's' consists only of lowercase English letters.
Output
Print the least common multiple (LCM) of the frequencies of all characters in a given string 's'.
Example
Sample Input 1:
abca

Sample Output 1:
2

Explanation 1:
frequency of 'a' = 2,
frequency of 'b' = 1,
frequency of 'c' = 1,
LCM(2, 1, 1) = 2.
solution--

#include<bits/stdc++.h>
using namespace std;

int gcd(int a, int b) {
    if (b == 0)
        return a;
    return gcd(b, a % b);
}

int lcm(int a, int b) {
    return (a * b) / gcd(a, b);
}

int frequency_lcm(const string& s) {
    unordered_map<char, int> freq_map;
    
    for (char c : s) {
        freq_map[c]++;
    }

    int lcm_freq = 1;
    for (const auto& pair : freq_map) {
        lcm_freq = lcm(lcm_freq, pair.second);
    }

    return lcm_freq;
}

int main() {
    string s;
    cin >> s;

    int result = frequency_lcm(s);
    cout << result << endl;

    return 0;
}

Distinct GCD
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
You are a genius at maths and Newton decided to check your knowledge so he gave you three integers N, X, and Y. You have to construct an array a1, a2,... , aN (X ≤ ai ≤ Y) such that GCD (i, ai) for 1 ≤ i ≤ N are all distinct. Print YES if it is possible to do so else print NO.
Input
The first line of the input contains three space-separated integers denoting N, X, and Y.

Constraints
1 ≤ N ≤ 105
1 ≤ X ≤ Y ≤ 109
Output
Print YES if it is possible to construct the array else print NO.
Example
Sample Input
5 1 5
Sample Output
YES
Explanation
You can choose the elements of the array as 1, 2, 3, 4, 5, therefore, GCD(i, ai) will be 1, 2, 3, 4, 5 which are all distinct.

solution--
#include <iostream>
using namespace std;

string can_construct_array(int N, int X, int Y) {
    int max_distinct_gcds = N;
    int max_possible_value = X + N - 1;
    return (Y >= max_possible_value) ? "YES" : "NO";
}

int main() {
    int N, X, Y;
    cin >> N >> X >> Y;

    string result = can_construct_array(N, X, Y);
    cout << result << endl;

    return 0;
}

Yash and money
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Yash wants to become rich so he decided to rob a house full of jewellery. He takes his N friends(including him) decided to visit the house at night and rob all the jewellery. The house contains a total of X kg of jewellery. Every friend has the capacity of carrying up at most Y kg of jewellery.

Find out whether Yash and his friends will be able to steal all the jewellery from the house
Input
The only line contains N, X, and Y denoting the number of friends(including Yash), jewellery weight, and capacity of every friend respectively.

Constraints
1 ≤ N, X, Y ≤ 1000
Output
Print(without quotes) "Yes" if Yash and his friends will be able to steal all jewellery from the house otherwise print(without quotes) "No".
Example
Sample Input
2 10 3

Sample Output
No

Explanation
2 people carry 3-3 Kg each so in total they can carry 6Kg which is less than 10Kg. Hence they won't be ale to steal all jewellery from the house.
Hence "No"(without quotes) will be printed.

solution--
#include <iostream>

using namespace std;

string canCarryJewellery(int n, int total_weight, int capacity) {
    int total_capacity = n * capacity;

    if (total_capacity >= total_weight) {
        return "Yes";
    } else {
        return "No";
    }
}

int main() {
    int n, total_weight, capacity;
    cin >> n;
    cin >> total_weight;
    cin >> capacity;

    string result = canCarryJewellery(n, total_weight, capacity);
    cout << result << endl;

    return 0;
}
