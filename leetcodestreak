date==14/5/23
Maximize Score After N Operations

You are given nums, an array of positive integers of size 2 * n. You must perform n operations on this array.

In the ith operation (1-indexed), you will:

Choose two elements, x and y.
Receive a score of i * gcd(x, y).
Remove x and y from nums.
Return the maximum score you can receive after performing n operations.

The function gcd(x, y) is the greatest common divisor of x and y.

 

Example 1:

Input: nums = [1,2]
Output: 1
Explanation: The optimal choice of operations is:
(1 * gcd(1, 2)) = 1
Example 2:

Input: nums = [3,4,6,8]
Output: 11
Explanation: The optimal choice of operations is:
(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11
Example 3:

Input: nums = [1,2,3,4,5,6]
Output: 14
Explanation: The optimal choice of operations is:
(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14
 

Constraints:

1 <= n <= 7
nums.length == 2 * n
1 <= nums[i] <= 106
solution:
class Solution {
public:
    int maxScore(vector<int>& nums) {
        int n = nums.size();
        
        
        vector<vector<int>> gcdMatrix(n, vector<int>(n));
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                gcdMatrix[i][j] = gcdMatrix[j][i] = gcd(nums[i], nums[j]);
            }
        }
        
        
        vector<int> dp(1 << n);
        
        
        for (int state = 1; state < (1 << n); state++) {
            
            int cnt = __builtin_popcount(state);
            
            
            if (cnt % 2 == 1) {
                continue;
            }
            
            
            for (int i = 0; i < n; i++) {
                if ((state & (1 << i)) == 0) {
                    continue;
                }
                for (int j = i + 1; j < n; j++) {
                    if ((state & (1 << j)) == 0) {
                        continue;
                    }
                    int nextState = state ^ (1 << i) ^ (1 << j);
                    dp[state] = max(dp[state], dp[nextState] + cnt / 2 * gcdMatrix[i][j]);
                }
            }
        }
        
        return dp[(1 << n) - 1];
    }
    
    int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
};
day 4 15-05-23
1721. Swapping Nodes in a Linked List
Medium
4.3K
143
Companies
You are given the head of a linked list, and an integer k.

Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).

 

Example 1:


Input: head = [1,2,3,4,5], k = 2
Output: [1,4,3,2,5]
Example 2:

Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5
Output: [7,9,6,6,8,7,3,0,9,5]
solution:-
class Solution {
public:
    ListNode* swapNodes(ListNode* head, int k) {
        ListNode *left_ptr = head, *right_ptr = head;
        for (int i = 0; i < k-1; i++) {
            right_ptr = right_ptr->next;
        }
        
        ListNode *end_ptr = right_ptr;
        while (right_ptr->next) {
            left_ptr = left_ptr->next;
            right_ptr = right_ptr->next;
        }
        
        swap(end_ptr->val, left_ptr->val);
        
        return head;
    }
};

day -8-7-2023
2551. Put Marbles in Bags
Hard

925

34

Add to List

Share
You have k bags. You are given a 0-indexed integer array weights where weights[i] is the weight of the ith marble. You are also given the integer k.

Divide the marbles into the k bags according to the following rules:

No bag is empty.
If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.
If a bag consists of all the marbles with an index from i to j inclusively, then the cost of the bag is weights[i] + weights[j].
The score after distributing the marbles is the sum of the costs of all the k bags.

Return the difference between the maximum and minimum scores among marble distributions.

 

Example 1:

Input: weights = [1,3,5,1], k = 2
Output: 4
Explanation: 
The distribution [1],[3,5,1] results in the minimal score of (1+1) + (3+1) = 6. 
The distribution [1,3],[5,1], results in the maximal score of (1+3) + (5+1) = 10. 
Thus, we return their difference 10 - 6 = 4.
Example 2:

Input: weights = [1, 3], k = 2
Output: 0
Explanation: The only distribution possible is [1],[3]. 
Since both the maximal and minimal score are the same, we return 0.
 

Constraints:

1 <= k <= weights.length <= 105
1 <= weights[i] <= 109
//greedy algorithm 
class Solution {
public:
    long long putMarbles(vector<int>& weights, int k) {
        int n=weights.size();
        vector<int>arr(n-1);
        for(int i=0;i<n-1;i++){
            arr[i]=weights[i]+weights[i+1];
        }
        sort(arr.begin(),arr.end());
        long long ans=0;
        k--;
        n--;
        for(int i=0;i<k;i++){
            ans-=arr[i];
            ans+=arr[n-i-1];
        }
        return ans;
    }
};
//priority queue algorithm
class Solution {
public:
    long long putMarbles(vector<int>& weights, int k) {
priority_queue<int> po;
priority_queue<int,vector<int>,greater<int>> po2;
long long ii=0;
for(int i=0;i+1<weights.size();i++){
    po.push(weights[i]+weights[i+1]);
    po2.push(weights[i]+weights[i+1]);
}
long long ii2=0;
while(k>1){
ii2+=(po.top()-po2.top());
po.pop();
po2.pop();
k--;
}
return ii2;
    }
};

9-7-2023
2272. Substring With Largest Variance
The variance of a string is defined as the largest difference between the number of occurrences of any 2 characters present in the string. Note the two characters may or may not be the same.

Given a string s consisting of lowercase English letters only, return the largest variance possible among all substrings of s.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: s = "aababbb"
Output: 3
Explanation:
All possible variances along with their respective substrings are listed below:
- Variance 0 for substrings "a", "aa", "ab", "abab", "aababb", "ba", "b", "bb", and "bbb".
- Variance 1 for substrings "aab", "aba", "abb", "aabab", "ababb", "aababbb", and "bab".
- Variance 2 for substrings "aaba", "ababbb", "abbb", and "babb".
- Variance 3 for substring "babbb".
Since the largest possible variance is 3, we return it.
Example 2:

Input: s = "abcde"
Output: 0
Explanation:
No letter occurs more than once in s, so the variance of every substring is 0.
 

Constraints:

1 <= s.length <= 104
s consists of lowercase English letters.

solution--
class Solution {
public:
    int largestVariance(string s) {
        vector<int> freq(26,0);
        for(int i=0;i<s.length();i++)
            freq[s[i]-'a']++;
        int ans=0;
        for(int i=0;i<26;i++){
            for(int j=0;j<26;j++){
                if(i==j || freq[i]==0 || freq[j]==0) continue;
                int c1=0,c2=0,rmc=freq[j];
                for(auto ch: s){
                    if(ch=='a'+i) c1++;
                    if(ch=='a'+j){
                        c2++;
                        rmc--;
                    }
                    if(c2>0) ans=max(ans,c1-c2);
                    if(c1<c2 && rmc>0){
                        c1=0;
                        c2=0;
                    }
                }
            }
        }
        return ans;
    }
};

10-7-2023
111. Minimum Depth of Binary Tree
Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

Note: A leaf is a node with no children.

 

Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: 2
Example 2:

Input: root = [2,null,3,null,4,null,5,null,6]
Output: 5
 

Constraints:

The number of nodes in the tree is in the range [0, 105].
-1000 <= Node.val <= 1000

solution--by using recursion solution of dfs--
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root==NULL) return 0;
        if(root->left==NULL || root->right== NULL) return 1+minDepth(root->right)+minDepth(root->left);
        else return (1+min(minDepth(root->left),minDepth(root->right)));
    }
};


13-7-2023
802. Find Eventual Safe States
There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].

A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node).

Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.

 

Example 1:

Illustration of graph
Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]
Output: [2,4,5,6]
Explanation: The given graph is shown above.
Nodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.
Every path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.
Example 2:

Input: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
Output: [4]
Explanation:
Only node 4 is a terminal node, and every path starting at node 4 leads to node 4.

class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int>adj[n];
        vector<int>indegree(n,0);

        for(int i=0;i<n;i++){
            for(auto it:graph[i]){
                adj[it].push_back(i);
                indegree[i]++;
            }
        }
        queue<int>q;
        for(int i=0;i<n;i++){
            if(indegree[i]==0){
                q.push(i);
            }
        }
        vector<int>safeNodes;
        while(!q.empty()){
            int node = q.front();
            q.pop();
            safeNodes.push_back(node);
            for(auto it:adj[node]){
                indegree[it]--;
                if(indegree[it]==0){
                    q.push(it);
                }
            }
        }

        sort(safeNodes.begin(),safeNodes.end());
        return safeNodes;
    }
};

13-07-23
207. Course Schedule
There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return true if you can finish all courses. Otherwise, return false.

 

Example 1:

Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
Example 2:

Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
 

Constraints:

1 <= numCourses <= 2000
0 <= prerequisites.length <= 5000
prerequisites[i].length == 2
0 <= ai, bi < numCourses
All the pairs prerequisites[i] are unique.
solution--
class Solution {
public:
bool dfs(vector<int> * list,vector<int> &visited,int source){
    if(visited[source])
    {
    return false;

    }
    visited[source]=true;
    for(auto child: list[source]){
        if(visited[child]!=2){

        
        if(dfs(list,visited,child)==false){
            return false;
        }
        }
    }
    visited[source]=2;
    return true;
}
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
     int n=numCourses;
     vector<int> list [n];
     for(int i=0;i<prerequisites.size();i++){
             list[prerequisites[i][0]].push_back(prerequisites[i][1]);
         
     }   
     vector<int> visited(n+1,false);
     for(int i=0;i<n;i++){
         if(!visited[i]){
             if(dfs(list,visited,i)==false){
                 return false;
             }
         }
     }
     return true;
    }
};

1218. Longest Arithmetic Subsequence of Given Difference
Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference.

A subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements.

 

Example 1:

Input: arr = [1,2,3,4], difference = 1
Output: 4
Explanation: The longest arithmetic subsequence is [1,2,3,4].
Example 2:

Input: arr = [1,3,5,7], difference = 1
Output: 1
Explanation: The longest arithmetic subsequence is any single element.
Example 3:

Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2
Output: 4
Explanation: The longest arithmetic subsequence is [7,5,3,1].
 

Constraints:

1 <= arr.length <= 105
-104 <= arr[i], difference <= 104

solution--
class Solution {
public:
    int longestSubsequence(vector<int>& arr, int difference) {
        unordered_map<int, int> dp;
        int maxLength = 0;

        for (int num : arr) {
            int prevNum = num - difference;
            if (dp.count(prevNum)) {
                dp[num] = dp[prevNum] + 1;
            } else {
                dp[num] = 1;
            }
            maxLength = max(maxLength, dp[num]);
        }

        return maxLength;  
    }
};


1125. Smallest Sufficient Team
In a project, you have a list of required skills req_skills, and a list of people. The ith person people[i] contains a list of skills that the person has.

Consider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.

For example, team = [0, 1, 3] represents the people with skills people[0], people[1], and people[3].
Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.

It is guaranteed an answer exists.

 

Example 1:

Input: req_skills = ["java","nodejs","reactjs"], people = [["java"],["nodejs"],["nodejs","reactjs"]]
Output: [0,2]
Example 2:

Input: req_skills = ["algorithms","math","java","reactjs","csharp","aws"], people = [["algorithms","math","java"],["algorithms","math","reactjs"],["java","csharp","aws"],["reactjs","csharp"],["csharp","math"],["aws","java"]]
Output: [1,2]
 

Constraints:

1 <= req_skills.length <= 16
1 <= req_skills[i].length <= 16
req_skills[i] consists of lowercase English letters.
All the strings of req_skills are unique.
1 <= people.length <= 60
0 <= people[i].length <= 16
1 <= people[i][j].length <= 16
people[i][j] consists of lowercase English letters.
All the strings of people[i] are unique.
Every skill in people[i] is a skill in req_skills.
It is guaranteed a sufficient team exists.

solution--
class Solution {
public:

    int countBits(long long x){
     // counts the number of set bits in a long long int
        int count=0;
        for(int i=0;i<64;i++){
            if(x&(1LL<<i)) count++;
        }
        return count;
    }
    long long findMin(int i,int skills,int allSkills,vector<int>&peo,vector<vector<long long>>&dp){
      if(i==peo.size()){
             if(skills!=allSkills) {
                return (1LL<<i)-1LL;
             }
             return 0LL;
         }
         if(dp[i][skills]!=-1) return dp[i][skills];
         int temp=skills;
         long long notPick=findMin(i+1,skills,allSkills,peo,dp);
         temp|=peo[i];
         if(temp==skills) return notPick;
         long long pick=findMin(i+1,temp,allSkills,peo,dp);
        
         pick|=(1LL<<i);
        int x=countBits(pick);
        int y=countBits(notPick);
        if(x<y) return dp[i][skills]=pick;
        return dp[i][skills]=notPick;
         
         
    }
    vector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) {
        map<string,int>m;
        int n=req_skills.size();
        for(int i=0;i<n;i++){
            m[req_skills[i]]=i;
        }
        vector<int>peo(people.size(),0);
        for(int i=0;i<peo.size();i++){
            for(auto str:people[i]){
                peo[i]|=(1<<m[str]);
            }
        }
        
        int allSkills=(1<<n)-1;
        
             vector<vector<long long>>dp(peo.size(),vector<long long>(allSkills+1,-1));
        long long ans= findMin(0,0,allSkills,peo,dp);
        vector<int>res;
        for(int i=0;i<64;i++){
            if(ans&(1LL<<i)) res.push_back(i);
        }
   
        return res;
    }
};

445. Add Two Numbers II
You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

 

Example 1:


Input: l1 = [7,2,4,3], l2 = [5,6,4]
Output: [7,8,0,7]
Example 2:

Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [8,0,7]
Example 3:

Input: l1 = [0], l2 = [0]
Output: [0]
 

Constraints:

The number of nodes in each linked list is in the range [1, 100].
0 <= Node.val <= 9
It is guaranteed that the list represents a number that does not have leading zeros.

solution--
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

        stack<int> st1,st2;
        while(l1){ 
            st1.push(l1->val);
            l1 = l1->next;
        }
        // cout<<endl;
        while(l2){ 
            st2.push(l2->val);
            l2 = l2->next;
        }

        ListNode* result = NULL;

        int carry = 0;

        while(!st1.empty() || !st2.empty() || carry != 0){
            int num1 = ( !st1.empty() )? st1.top(): 0;
            int num2 = ( !st2.empty() )? st2.top(): 0;

            int sum = num1 + num2 + carry;
            carry = sum / 10;
            int rem = sum%10;

            ListNode* newNode = new ListNode(rem);
            newNode->next = result;
            result = newNode;

            if( !st1.empty() ) st1.pop();
            if( !st2.empty() ) st2.pop();

        }

        return result;
    }
};

435. Non-overlapping Intervals
Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.

 

Example 1:

Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
Example 2:

Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
Example 3:

Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
 

Constraints:

1 <= intervals.length <= 105
intervals[i].length == 2
-5 * 104 <= starti < endi <= 5 * 104

solution--
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        int result = 0;

        sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {
            return a[0] < b[0];
        }); 

        for (int i = 0; i < intervals.size()-1; i++) {
            // no overlap
            if (intervals[i][1] <= intervals[i+1][0]) continue;
            // overlap
            intervals[i+1][0] = intervals[i][0];
            intervals[i+1][1] = min(intervals[i][1], intervals[i+1][1]);
            result++;
        }

        return result;
    }
};

735. Asteroid Collision
We are given an array asteroids of integers representing asteroids in a row.

For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.

Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.

 

Example 1:

Input: asteroids = [5,10,-5]
Output: [5,10]
Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.
Example 2:

Input: asteroids = [8,-8]
Output: []
Explanation: The 8 and -8 collide exploding each other.
Example 3:

Input: asteroids = [10,2,-5]
Output: [10]
Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.
 

Constraints:

2 <= asteroids.length <= 104
-1000 <= asteroids[i] <= 1000
asteroids[i] != 0

solution--
class Solution {
public:
    vector<int> asteroidCollision(vector<int>& asteroids) {
                stack<pair<int,char>>st;
        for(int i=0;i<asteroids.size();i++)
        {
            char ch = 'R';
            if(asteroids[i]<0)ch='L';

            if(st.empty())
            {
                st.push({asteroids[i],ch});
                continue;
            }

            if(st.top().second==ch)st.push({asteroids[i],ch});
            else
            {
                if(ch=='R')st.push({asteroids[i],ch});
                else
                {
                    pair<int,char>t=st.top();
                    int flag=1;
                    while(t.second!=ch)
                    {
                        
                        if(t.first == abs(asteroids[i]))
                            {st.pop(),flag=0;break;}
                        else if(t.first<abs(asteroids[i]))
                            st.pop();
                        else 
                            {flag=0;break;}

                        if(st.empty())
                            break;
                        t = st.top();
                     
                    }
                    
                    if(flag)
                        st.push({asteroids[i],ch});
                }
            }
        }
        vector<int>ans;
        int s = st.size();
        for(int i=0;i<s;i++)
        {ans.push_back(st.top().first);st.pop();}

        reverse(ans.begin(),ans.end());
        return ans;
    }
};

673. Number of Longest Increasing Subsequence
Given an integer array nums, return the number of longest increasing subsequences.

Notice that the sequence has to be strictly increasing.

 

Example 1:

Input: nums = [1,3,5,4,7]
Output: 2
Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].
Example 2:

Input: nums = [2,2,2,2,2]
Output: 5
Explanation: The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.
 

Constraints:

1 <= nums.length <= 2000
-106 <= nums[i] <= 106

solution--

class Solution {
public:
    int findNumberOfLIS(vector<int>& nums) {
        int n = nums.size(), lenLis = 1;
        vector<int> dp(n, 1), cnt(n, 1);
        // dp[i] = length of LIS ending at index i
        // cnt[i] = count of LIS of length dp[i] ending at index i
    
        for(int i=0; i<n; i++){
            for(int prev = 0; prev < i; prev++ ){
                if( nums[prev] < nums[i] && dp[prev] + 1 > dp[i] ){
                    dp[i] = dp[prev] + 1; 
                    cnt[i] = cnt[prev];
                }
                else if( nums[prev] < nums[i] && dp[prev] + 1 == dp[i] ) cnt[i] += cnt[prev];
            } 
            lenLis = max(lenLis, dp[i]);
        }

        int ans = 0;
        for(int i=0; i<n; i++ ) ans += (dp[i] == lenLis ? cnt[i] : 0);
        return ans;
    }
};

688. Knight Probability in Chessboard
On an n x n chessboard, a knight starts at the cell (row, column) and attempts to make exactly k moves. The rows and columns are 0-indexed, so the top-left cell is (0, 0), and the bottom-right cell is (n - 1, n - 1).

A chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.


Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.

The knight continues moving until it has made exactly k moves or has moved off the chessboard.

Return the probability that the knight remains on the board after it has stopped moving.

 

Example 1:

Input: n = 3, k = 2, row = 0, column = 0
Output: 0.06250
Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.
From each of those positions, there are also two moves that will keep the knight on the board.
The total probability the knight stays on the board is 0.0625.
Example 2:

Input: n = 1, k = 0, row = 0, column = 0
Output: 1.00000
 

Constraints:

1 <= n <= 25
0 <= k <= 100
0 <= row, column <= n - 1

solution--
class Solution {
public:
    double knightProbability(int n, int k, int row, int column) {
        int moves[8][2]={{-2,-1},{-1,-2},{1,-2},{2,-1},{1,2},{2,1},{-1,2},{-2,1}};
        vector<vector<double>> v1(n,vector<double>(n,0));
        vector<vector<double>> v2(n,vector<double>(n,0));
        vector<vector<double>> &v = v1;
        vector<vector<double>> &vn = v2;
        v[row][column]=1;
        for(; k>0; k--)
        {
            for(int i=0; i<n; i++)
            {
                for(int j=0; j<n; j++)
                {
                    double f=v[i][j]/8;  
                    v[i][j] = 0;         
                    for(int l=0; l<8; l++)
                    {
                        int y=i+moves[l][0];
                        int x=j+moves[l][1];
                        if (y >=0 && y <n && x>=0 && x<n)
                            vn[y][x] += f;  
                    }
                }

            }
            swap(v,vn);
        }
        double ans = 0;
        for(int i=0; i<n; i++)
            for(int j=0; j<n; j++)
               ans += v[i][j];  
        
        return ans;

    }
};
