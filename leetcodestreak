date==14/5/23
Maximize Score After N Operations

You are given nums, an array of positive integers of size 2 * n. You must perform n operations on this array.

In the ith operation (1-indexed), you will:

Choose two elements, x and y.
Receive a score of i * gcd(x, y).
Remove x and y from nums.
Return the maximum score you can receive after performing n operations.

The function gcd(x, y) is the greatest common divisor of x and y.

 

Example 1:

Input: nums = [1,2]
Output: 1
Explanation: The optimal choice of operations is:
(1 * gcd(1, 2)) = 1
Example 2:

Input: nums = [3,4,6,8]
Output: 11
Explanation: The optimal choice of operations is:
(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11
Example 3:

Input: nums = [1,2,3,4,5,6]
Output: 14
Explanation: The optimal choice of operations is:
(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14
 

Constraints:

1 <= n <= 7
nums.length == 2 * n
1 <= nums[i] <= 106
solution:
class Solution {
public:
    int maxScore(vector<int>& nums) {
        int n = nums.size();
        
        
        vector<vector<int>> gcdMatrix(n, vector<int>(n));
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                gcdMatrix[i][j] = gcdMatrix[j][i] = gcd(nums[i], nums[j]);
            }
        }
        
        
        vector<int> dp(1 << n);
        
        
        for (int state = 1; state < (1 << n); state++) {
            
            int cnt = __builtin_popcount(state);
            
            
            if (cnt % 2 == 1) {
                continue;
            }
            
            
            for (int i = 0; i < n; i++) {
                if ((state & (1 << i)) == 0) {
                    continue;
                }
                for (int j = i + 1; j < n; j++) {
                    if ((state & (1 << j)) == 0) {
                        continue;
                    }
                    int nextState = state ^ (1 << i) ^ (1 << j);
                    dp[state] = max(dp[state], dp[nextState] + cnt / 2 * gcdMatrix[i][j]);
                }
            }
        }
        
        return dp[(1 << n) - 1];
    }
    
    int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
};
day 4 15-05-23
1721. Swapping Nodes in a Linked List
Medium
4.3K
143
Companies
You are given the head of a linked list, and an integer k.

Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).

 

Example 1:


Input: head = [1,2,3,4,5], k = 2
Output: [1,4,3,2,5]
Example 2:

Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5
Output: [7,9,6,6,8,7,3,0,9,5]
solution:-
class Solution {
public:
    ListNode* swapNodes(ListNode* head, int k) {
        ListNode *left_ptr = head, *right_ptr = head;
        for (int i = 0; i < k-1; i++) {
            right_ptr = right_ptr->next;
        }
        
        ListNode *end_ptr = right_ptr;
        while (right_ptr->next) {
            left_ptr = left_ptr->next;
            right_ptr = right_ptr->next;
        }
        
        swap(end_ptr->val, left_ptr->val);
        
        return head;
    }
};

day -8-7-2023
2551. Put Marbles in Bags
Hard

925

34

Add to List

Share
You have k bags. You are given a 0-indexed integer array weights where weights[i] is the weight of the ith marble. You are also given the integer k.

Divide the marbles into the k bags according to the following rules:

No bag is empty.
If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.
If a bag consists of all the marbles with an index from i to j inclusively, then the cost of the bag is weights[i] + weights[j].
The score after distributing the marbles is the sum of the costs of all the k bags.

Return the difference between the maximum and minimum scores among marble distributions.

 

Example 1:

Input: weights = [1,3,5,1], k = 2
Output: 4
Explanation: 
The distribution [1],[3,5,1] results in the minimal score of (1+1) + (3+1) = 6. 
The distribution [1,3],[5,1], results in the maximal score of (1+3) + (5+1) = 10. 
Thus, we return their difference 10 - 6 = 4.
Example 2:

Input: weights = [1, 3], k = 2
Output: 0
Explanation: The only distribution possible is [1],[3]. 
Since both the maximal and minimal score are the same, we return 0.
 

Constraints:

1 <= k <= weights.length <= 105
1 <= weights[i] <= 109
//greedy algorithm 
class Solution {
public:
    long long putMarbles(vector<int>& weights, int k) {
        int n=weights.size();
        vector<int>arr(n-1);
        for(int i=0;i<n-1;i++){
            arr[i]=weights[i]+weights[i+1];
        }
        sort(arr.begin(),arr.end());
        long long ans=0;
        k--;
        n--;
        for(int i=0;i<k;i++){
            ans-=arr[i];
            ans+=arr[n-i-1];
        }
        return ans;
    }
};
//priority queue algorithm
class Solution {
public:
    long long putMarbles(vector<int>& weights, int k) {
priority_queue<int> po;
priority_queue<int,vector<int>,greater<int>> po2;
long long ii=0;
for(int i=0;i+1<weights.size();i++){
    po.push(weights[i]+weights[i+1]);
    po2.push(weights[i]+weights[i+1]);
}
long long ii2=0;
while(k>1){
ii2+=(po.top()-po2.top());
po.pop();
po2.pop();
k--;
}
return ii2;
    }
};

9-7-2023
2272. Substring With Largest Variance
The variance of a string is defined as the largest difference between the number of occurrences of any 2 characters present in the string. Note the two characters may or may not be the same.

Given a string s consisting of lowercase English letters only, return the largest variance possible among all substrings of s.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: s = "aababbb"
Output: 3
Explanation:
All possible variances along with their respective substrings are listed below:
- Variance 0 for substrings "a", "aa", "ab", "abab", "aababb", "ba", "b", "bb", and "bbb".
- Variance 1 for substrings "aab", "aba", "abb", "aabab", "ababb", "aababbb", and "bab".
- Variance 2 for substrings "aaba", "ababbb", "abbb", and "babb".
- Variance 3 for substring "babbb".
Since the largest possible variance is 3, we return it.
Example 2:

Input: s = "abcde"
Output: 0
Explanation:
No letter occurs more than once in s, so the variance of every substring is 0.
 

Constraints:

1 <= s.length <= 104
s consists of lowercase English letters.

solution--
class Solution {
public:
    int largestVariance(string s) {
        vector<int> freq(26,0);
        for(int i=0;i<s.length();i++)
            freq[s[i]-'a']++;
        int ans=0;
        for(int i=0;i<26;i++){
            for(int j=0;j<26;j++){
                if(i==j || freq[i]==0 || freq[j]==0) continue;
                int c1=0,c2=0,rmc=freq[j];
                for(auto ch: s){
                    if(ch=='a'+i) c1++;
                    if(ch=='a'+j){
                        c2++;
                        rmc--;
                    }
                    if(c2>0) ans=max(ans,c1-c2);
                    if(c1<c2 && rmc>0){
                        c1=0;
                        c2=0;
                    }
                }
            }
        }
        return ans;
    }
};

10-7-2023
111. Minimum Depth of Binary Tree
Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

Note: A leaf is a node with no children.

 

Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: 2
Example 2:

Input: root = [2,null,3,null,4,null,5,null,6]
Output: 5
 

Constraints:

The number of nodes in the tree is in the range [0, 105].
-1000 <= Node.val <= 1000

solution--by using recursion solution of dfs--
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root==NULL) return 0;
        if(root->left==NULL || root->right== NULL) return 1+minDepth(root->right)+minDepth(root->left);
        else return (1+min(minDepth(root->left),minDepth(root->right)));
    }
};


13-7-2023
802. Find Eventual Safe States
There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].

A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node).

Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.

 

Example 1:

Illustration of graph
Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]
Output: [2,4,5,6]
Explanation: The given graph is shown above.
Nodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.
Every path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.
Example 2:

Input: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
Output: [4]
Explanation:
Only node 4 is a terminal node, and every path starting at node 4 leads to node 4.

class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int>adj[n];
        vector<int>indegree(n,0);

        for(int i=0;i<n;i++){
            for(auto it:graph[i]){
                adj[it].push_back(i);
                indegree[i]++;
            }
        }
        queue<int>q;
        for(int i=0;i<n;i++){
            if(indegree[i]==0){
                q.push(i);
            }
        }
        vector<int>safeNodes;
        while(!q.empty()){
            int node = q.front();
            q.pop();
            safeNodes.push_back(node);
            for(auto it:adj[node]){
                indegree[it]--;
                if(indegree[it]==0){
                    q.push(it);
                }
            }
        }

        sort(safeNodes.begin(),safeNodes.end());
        return safeNodes;
    }
};

13-07-23
207. Course Schedule
There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return true if you can finish all courses. Otherwise, return false.

 

Example 1:

Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
Example 2:

Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
 

Constraints:

1 <= numCourses <= 2000
0 <= prerequisites.length <= 5000
prerequisites[i].length == 2
0 <= ai, bi < numCourses
All the pairs prerequisites[i] are unique.
solution--
class Solution {
public:
bool dfs(vector<int> * list,vector<int> &visited,int source){
    if(visited[source])
    {
    return false;

    }
    visited[source]=true;
    for(auto child: list[source]){
        if(visited[child]!=2){

        
        if(dfs(list,visited,child)==false){
            return false;
        }
        }
    }
    visited[source]=2;
    return true;
}
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
     int n=numCourses;
     vector<int> list [n];
     for(int i=0;i<prerequisites.size();i++){
             list[prerequisites[i][0]].push_back(prerequisites[i][1]);
         
     }   
     vector<int> visited(n+1,false);
     for(int i=0;i<n;i++){
         if(!visited[i]){
             if(dfs(list,visited,i)==false){
                 return false;
             }
         }
     }
     return true;
    }
};

1218. Longest Arithmetic Subsequence of Given Difference
Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference.

A subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements.

 

Example 1:

Input: arr = [1,2,3,4], difference = 1
Output: 4
Explanation: The longest arithmetic subsequence is [1,2,3,4].
Example 2:

Input: arr = [1,3,5,7], difference = 1
Output: 1
Explanation: The longest arithmetic subsequence is any single element.
Example 3:

Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2
Output: 4
Explanation: The longest arithmetic subsequence is [7,5,3,1].
 

Constraints:

1 <= arr.length <= 105
-104 <= arr[i], difference <= 104

solution--
class Solution {
public:
    int longestSubsequence(vector<int>& arr, int difference) {
        unordered_map<int, int> dp;
        int maxLength = 0;

        for (int num : arr) {
            int prevNum = num - difference;
            if (dp.count(prevNum)) {
                dp[num] = dp[prevNum] + 1;
            } else {
                dp[num] = 1;
            }
            maxLength = max(maxLength, dp[num]);
        }

        return maxLength;  
    }
};


1125. Smallest Sufficient Team
In a project, you have a list of required skills req_skills, and a list of people. The ith person people[i] contains a list of skills that the person has.

Consider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.

For example, team = [0, 1, 3] represents the people with skills people[0], people[1], and people[3].
Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.

It is guaranteed an answer exists.

 

Example 1:

Input: req_skills = ["java","nodejs","reactjs"], people = [["java"],["nodejs"],["nodejs","reactjs"]]
Output: [0,2]
Example 2:

Input: req_skills = ["algorithms","math","java","reactjs","csharp","aws"], people = [["algorithms","math","java"],["algorithms","math","reactjs"],["java","csharp","aws"],["reactjs","csharp"],["csharp","math"],["aws","java"]]
Output: [1,2]
 

Constraints:

1 <= req_skills.length <= 16
1 <= req_skills[i].length <= 16
req_skills[i] consists of lowercase English letters.
All the strings of req_skills are unique.
1 <= people.length <= 60
0 <= people[i].length <= 16
1 <= people[i][j].length <= 16
people[i][j] consists of lowercase English letters.
All the strings of people[i] are unique.
Every skill in people[i] is a skill in req_skills.
It is guaranteed a sufficient team exists.

solution--
class Solution {
public:

    int countBits(long long x){
     // counts the number of set bits in a long long int
        int count=0;
        for(int i=0;i<64;i++){
            if(x&(1LL<<i)) count++;
        }
        return count;
    }
    long long findMin(int i,int skills,int allSkills,vector<int>&peo,vector<vector<long long>>&dp){
      if(i==peo.size()){
             if(skills!=allSkills) {
                return (1LL<<i)-1LL;
             }
             return 0LL;
         }
         if(dp[i][skills]!=-1) return dp[i][skills];
         int temp=skills;
         long long notPick=findMin(i+1,skills,allSkills,peo,dp);
         temp|=peo[i];
         if(temp==skills) return notPick;
         long long pick=findMin(i+1,temp,allSkills,peo,dp);
        
         pick|=(1LL<<i);
        int x=countBits(pick);
        int y=countBits(notPick);
        if(x<y) return dp[i][skills]=pick;
        return dp[i][skills]=notPick;
         
         
    }
    vector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) {
        map<string,int>m;
        int n=req_skills.size();
        for(int i=0;i<n;i++){
            m[req_skills[i]]=i;
        }
        vector<int>peo(people.size(),0);
        for(int i=0;i<peo.size();i++){
            for(auto str:people[i]){
                peo[i]|=(1<<m[str]);
            }
        }
        
        int allSkills=(1<<n)-1;
        
             vector<vector<long long>>dp(peo.size(),vector<long long>(allSkills+1,-1));
        long long ans= findMin(0,0,allSkills,peo,dp);
        vector<int>res;
        for(int i=0;i<64;i++){
            if(ans&(1LL<<i)) res.push_back(i);
        }
   
        return res;
    }
};

445. Add Two Numbers II
You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

 

Example 1:


Input: l1 = [7,2,4,3], l2 = [5,6,4]
Output: [7,8,0,7]
Example 2:

Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [8,0,7]
Example 3:

Input: l1 = [0], l2 = [0]
Output: [0]
 

Constraints:

The number of nodes in each linked list is in the range [1, 100].
0 <= Node.val <= 9
It is guaranteed that the list represents a number that does not have leading zeros.

solution--
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

        stack<int> st1,st2;
        while(l1){ 
            st1.push(l1->val);
            l1 = l1->next;
        }
        // cout<<endl;
        while(l2){ 
            st2.push(l2->val);
            l2 = l2->next;
        }

        ListNode* result = NULL;

        int carry = 0;

        while(!st1.empty() || !st2.empty() || carry != 0){
            int num1 = ( !st1.empty() )? st1.top(): 0;
            int num2 = ( !st2.empty() )? st2.top(): 0;

            int sum = num1 + num2 + carry;
            carry = sum / 10;
            int rem = sum%10;

            ListNode* newNode = new ListNode(rem);
            newNode->next = result;
            result = newNode;

            if( !st1.empty() ) st1.pop();
            if( !st2.empty() ) st2.pop();

        }

        return result;
    }
};

435. Non-overlapping Intervals
Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.

 

Example 1:

Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
Example 2:

Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
Example 3:

Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
 

Constraints:

1 <= intervals.length <= 105
intervals[i].length == 2
-5 * 104 <= starti < endi <= 5 * 104

solution--
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        int result = 0;

        sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {
            return a[0] < b[0];
        }); 

        for (int i = 0; i < intervals.size()-1; i++) {
            // no overlap
            if (intervals[i][1] <= intervals[i+1][0]) continue;
            // overlap
            intervals[i+1][0] = intervals[i][0];
            intervals[i+1][1] = min(intervals[i][1], intervals[i+1][1]);
            result++;
        }

        return result;
    }
};

735. Asteroid Collision
We are given an array asteroids of integers representing asteroids in a row.

For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.

Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.

 

Example 1:

Input: asteroids = [5,10,-5]
Output: [5,10]
Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.
Example 2:

Input: asteroids = [8,-8]
Output: []
Explanation: The 8 and -8 collide exploding each other.
Example 3:

Input: asteroids = [10,2,-5]
Output: [10]
Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.
 

Constraints:

2 <= asteroids.length <= 104
-1000 <= asteroids[i] <= 1000
asteroids[i] != 0

solution--
class Solution {
public:
    vector<int> asteroidCollision(vector<int>& asteroids) {
                stack<pair<int,char>>st;
        for(int i=0;i<asteroids.size();i++)
        {
            char ch = 'R';
            if(asteroids[i]<0)ch='L';

            if(st.empty())
            {
                st.push({asteroids[i],ch});
                continue;
            }

            if(st.top().second==ch)st.push({asteroids[i],ch});
            else
            {
                if(ch=='R')st.push({asteroids[i],ch});
                else
                {
                    pair<int,char>t=st.top();
                    int flag=1;
                    while(t.second!=ch)
                    {
                        
                        if(t.first == abs(asteroids[i]))
                            {st.pop(),flag=0;break;}
                        else if(t.first<abs(asteroids[i]))
                            st.pop();
                        else 
                            {flag=0;break;}

                        if(st.empty())
                            break;
                        t = st.top();
                     
                    }
                    
                    if(flag)
                        st.push({asteroids[i],ch});
                }
            }
        }
        vector<int>ans;
        int s = st.size();
        for(int i=0;i<s;i++)
        {ans.push_back(st.top().first);st.pop();}

        reverse(ans.begin(),ans.end());
        return ans;
    }
};

673. Number of Longest Increasing Subsequence
Given an integer array nums, return the number of longest increasing subsequences.

Notice that the sequence has to be strictly increasing.

 

Example 1:

Input: nums = [1,3,5,4,7]
Output: 2
Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].
Example 2:

Input: nums = [2,2,2,2,2]
Output: 5
Explanation: The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.
 

Constraints:

1 <= nums.length <= 2000
-106 <= nums[i] <= 106

solution--

class Solution {
public:
    int findNumberOfLIS(vector<int>& nums) {
        int n = nums.size(), lenLis = 1;
        vector<int> dp(n, 1), cnt(n, 1);
        // dp[i] = length of LIS ending at index i
        // cnt[i] = count of LIS of length dp[i] ending at index i
    
        for(int i=0; i<n; i++){
            for(int prev = 0; prev < i; prev++ ){
                if( nums[prev] < nums[i] && dp[prev] + 1 > dp[i] ){
                    dp[i] = dp[prev] + 1; 
                    cnt[i] = cnt[prev];
                }
                else if( nums[prev] < nums[i] && dp[prev] + 1 == dp[i] ) cnt[i] += cnt[prev];
            } 
            lenLis = max(lenLis, dp[i]);
        }

        int ans = 0;
        for(int i=0; i<n; i++ ) ans += (dp[i] == lenLis ? cnt[i] : 0);
        return ans;
    }
};

688. Knight Probability in Chessboard
On an n x n chessboard, a knight starts at the cell (row, column) and attempts to make exactly k moves. The rows and columns are 0-indexed, so the top-left cell is (0, 0), and the bottom-right cell is (n - 1, n - 1).

A chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.


Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.

The knight continues moving until it has made exactly k moves or has moved off the chessboard.

Return the probability that the knight remains on the board after it has stopped moving.

 

Example 1:

Input: n = 3, k = 2, row = 0, column = 0
Output: 0.06250
Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.
From each of those positions, there are also two moves that will keep the knight on the board.
The total probability the knight stays on the board is 0.0625.
Example 2:

Input: n = 1, k = 0, row = 0, column = 0
Output: 1.00000
 

Constraints:

1 <= n <= 25
0 <= k <= 100
0 <= row, column <= n - 1

solution--
class Solution {
public:
    double knightProbability(int n, int k, int row, int column) {
        int moves[8][2]={{-2,-1},{-1,-2},{1,-2},{2,-1},{1,2},{2,1},{-1,2},{-2,1}};
        vector<vector<double>> v1(n,vector<double>(n,0));
        vector<vector<double>> v2(n,vector<double>(n,0));
        vector<vector<double>> &v = v1;
        vector<vector<double>> &vn = v2;
        v[row][column]=1;
        for(; k>0; k--)
        {
            for(int i=0; i<n; i++)
            {
                for(int j=0; j<n; j++)
                {
                    double f=v[i][j]/8;  
                    v[i][j] = 0;         
                    for(int l=0; l<8; l++)
                    {
                        int y=i+moves[l][0];
                        int x=j+moves[l][1];
                        if (y >=0 && y <n && x>=0 && x<n)
                            vn[y][x] += f;  
                    }
                }

            }
            swap(v,vn);
        }
        double ans = 0;
        for(int i=0; i<n; i++)
            for(int j=0; j<n; j++)
               ans += v[i][j];  
        
        return ans;

    }
};

894. All Possible Full Binary Trees
Given an integer n, return a list of all possible full binary trees with n nodes. Each node of each tree in the answer must have Node.val == 0.

Each element of the answer is the root node of one possible tree. You may return the final list of trees in any order.

A full binary tree is a binary tree where each node has exactly 0 or 2 children.

 

Example 1:


Input: n = 7
Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]
Example 2:

Input: n = 3
Output: [[0,0,0]]

solution--
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
       
      vector<TreeNode*> solve(int n){
            vector<TreeNode*> res;
            if(n%2==0)return res;
             if(n==1) {
                 TreeNode* root= new TreeNode(0);
                 res.push_back(root);
                 return res;
             }
            for(int i=1;i<=n-2;i+=2){
                vector<TreeNode*> l= solve(i);
                vector<TreeNode*> r= solve(n-i-1);
                for(int k=0;k<l.size();k++){
                    for(int p=0;p<r.size();p++){
                        TreeNode* root=new TreeNode(0);
                        root->left=l[k];
                        root->right=r[p];
                        res.push_back(root);
                    }
                }
            }
          return res;
      }
    vector<TreeNode*> allPossibleFBT(int n) {
          
      
        return solve(n) ;
    }
};

50. Pow(x, n)
Implement pow(x, n), which calculates x raised to the power n (i.e., xn).

 

Example 1:

Input: x = 2.00000, n = 10
Output: 1024.00000
Example 2:

Input: x = 2.10000, n = 3
Output: 9.26100
Example 3:

Input: x = 2.00000, n = -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
 

Constraints:

-100.0 < x < 100.0
-231 <= n <= 231-1
n is an integer.
Either x is not zero or n > 0.
-104 <= xn <= 104

solution---
class Solution {
public:
    double myPow(double x, int n) {
        if(n==0) return 1;
        if(n<0) {
            n = abs(n);
            x = 1/x;
        }
        if(n%2==0){
            return myPow(x*x, n/2);
        }
        else{
            return x*myPow(x, n-1);
        }
    }
};


852. Peak Index in a Mountain Array


Add to List
An array arr a mountain if the following properties hold:

arr.length >= 3
There exists some i with 0 < i < arr.length - 1 such that:
arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
Given a mountain array arr, return the index i such that arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1].

You must solve it in O(log(arr.length)) time complexity.

 

Example 1:

Input: arr = [0,1,0]
Output: 1
Example 2:

Input: arr = [0,2,1,0]
Output: 1
Example 3:

Input: arr = [0,10,5,2]
Output: 1
 

Constraints:

3 <= arr.length <= 105
0 <= arr[i] <= 106
arr is guaranteed to be a mountain array.


solution--
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
      int low = 0, high = arr.size()-1,mid;
       while(low<high){
           mid = (low+high)/2;
           if(arr[mid]<arr[mid+1]){
               low = mid+1;
           }else{
               high = mid;
           }
       }

       return low;
    }
};

1870. Minimum Speed to Arrive on Time
Medium

1930

226

Add to List

Share
You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.

Each train can only depart at an integer hour, so you may need to wait in between each train ride.

For example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.
Return the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.

Tests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.

 

Example 1:

Input: dist = [1,3,2], hour = 6
Output: 1
Explanation: At speed 1:
- The first train ride takes 1/1 = 1 hour.
- Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.
- Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.
- You will arrive at exactly the 6 hour mark.
Example 2:

Input: dist = [1,3,2], hour = 2.7
Output: 3
Explanation: At speed 3:
- The first train ride takes 1/3 = 0.33333 hours.
- Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.
- Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.
- You will arrive at the 2.66667 hour mark.
Example 3:

Input: dist = [1,3,2], hour = 1.9
Output: -1
Explanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.
 

Constraints:

n == dist.length
1 <= n <= 105
1 <= dist[i] <= 105
1 <= hour <= 109
There will be at most two digits after the decimal point in hour.

solution--
class Solution {
public:
    int minSpeedOnTime(vector<int>& dist, double hour) {
        int start = 1, n = dist.size(), end = 1e9;
        int speed = -1;
        while(start<=end){
            int mid = end-(end-start)/2;
            double totalTimeTaken = 0;
            for(int i=0; i<n; i++){
                double timeTaken = (double)dist[i]/mid;
                if (i != n-1){
                    timeTaken = ceil(timeTaken);
                }
                totalTimeTaken += timeTaken;    
            }
            if (totalTimeTaken <= hour){
                speed = mid;
                end = mid-1;
            }else{
                start = mid+1;
            }
        }
        return speed;
    }
};

2141. Maximum Running Time of N Computers

You have n computers. You are given the integer n and a 0-indexed integer array batteries where the ith battery can run a computer for batteries[i] minutes. You are interested in running all n computers simultaneously using the given batteries.

Initially, you can insert at most one battery into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery any number of times. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.

Note that the batteries cannot be recharged.

Return the maximum number of minutes you can run all the n computers simultaneously.

 

Example 1:


Input: n = 2, batteries = [3,3,3]
Output: 4
Explanation: 
Initially, insert battery 0 into the first computer and battery 1 into the second computer.
After two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.
At the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.
By the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.
We can run the two computers simultaneously for at most 4 minutes, so we return 4.

Example 2:


Input: n = 2, batteries = [1,1,1,1]
Output: 2
Explanation: 
Initially, insert battery 0 into the first computer and battery 2 into the second computer. 
After one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. 
After another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.
We can run the two computers simultaneously for at most 2 minutes, so we return 2.
 

Constraints:

1 <= n <= batteries.length <= 105
1 <= batteries[i] <= 109


solution--
class Solution {
public:
    long long maxRunTime(int n, vector<int>& b) {
      if(n>b.size()) return -1;
      
      long long sum =0;
      priority_queue<int> maxh;
      for(auto i : b){
         sum+=i;
         maxh.push(i);
      }
      while(maxh.top()>sum/n){
          sum-=maxh.top();
          maxh.pop();
          n--;
      }
      return sum/n;
     
      
    }
};

486. Predict the Winner
You are given an integer array nums. Two players are playing a game with this array: player 1 and player 2.

Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of 0. At each turn, the player takes one of the numbers from either end of the array (i.e., nums[0] or nums[nums.length - 1]) which reduces the size of the array by 1. The player adds the chosen number to their score. The game ends when there are no more elements in the array.

Return true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. You may assume that both players are playing optimally.

 

Example 1:

Input: nums = [1,5,2]
Output: false
Explanation: Initially, player 1 can choose between 1 and 2. 
If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). 
So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. 
Hence, player 1 will never be the winner and you need to return false.
Example 2:

Input: nums = [1,5,233,7]
Output: true
Explanation: Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.
Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.
 

Constraints:

1 <= nums.length <= 20
0 <= nums[i] <= 107

solution--
class Solution {
public:

    int dp[21][21];
    int solve(int start, int end, vector<int>& nums) {
          if(dp[start][end]!=-1)
        {
            return dp[start][end];
        }
        if (start == end) {
            return nums[start];
        }
      
        int pickStart = nums[start] - solve(start + 1, end, nums);
        int pickEnd = nums[end] - solve(start, end - 1, nums);

        return dp[start][end]=max(pickStart, pickEnd);
    }

    bool PredictTheWinner(vector<int>& nums) {
        int start = 0;
        int end = nums.size() - 1;

        memset(dp,-1,sizeof(dp));

        return solve(start, end, nums) >= 0;
    }
};



// class Solution {
// public:
//     bool PredictTheWinner(int nums[]) {
// //         int n=nums.size();
// //         int player1=0,player2=0;
// //         sort(nums.begin(),nums.end());
// //         for(int i=0;i<=n-1;i++){
// //            if(i%2==0) player1+=nums[i];
// //            else player2+=nums[i];
// //         }
// //         if(player1<player2) return false;
        
// //         return true;
        
//         recursive(nums,0,nums.length-1)>=0;
        
//     }
//     public: int recursive(int nums[],int start, int end){
        
//         if(start==end) return nums[start];
        
//         int left = nums[start] - recursive(nums,start+1,end);
//         int right = nums[end] - recursive(nums,start,end+1);
        
//         return Math.max(left,right);
        
//     }
// };

808. Soup Servings
There are two types of soup: type A and type B. Initially, we have n ml of each type of soup. There are four kinds of operations:

Serve 100 ml of soup A and 0 ml of soup B,
Serve 75 ml of soup A and 25 ml of soup B,
Serve 50 ml of soup A and 50 ml of soup B, and
Serve 25 ml of soup A and 75 ml of soup B.
When we serve some soup, we give it to someone, and we no longer have it. Each turn, we will choose from the four operations with an equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as possible. We stop once we no longer have some quantity of both types of soup.

Note that we do not have an operation where all 100 ml's of soup B are used first.

Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time. Answers within 10-5 of the actual answer will be accepted.

 

Example 1:

Input: n = 50
Output: 0.62500
Explanation: If we choose the first two operations, A will become empty first.
For the third operation, A and B will become empty at the same time.
For the fourth operation, B will become empty first.
So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.
Example 2:

Input: n = 100
Output: 0.71875
 

Constraints:

0 <= n <= 109

class Solution {
private:
     double help(int A, int B, unordered_map<int, unordered_map<int, double>> &dp){
        if(A <= 0) return B <= 0 ? 0.5 : 1.0;
        if(B <= 0) return 0.0;
        if(dp.find(A) != dp.end() && dp.at(A).find(B) != dp.at(A).end())
            return dp.at(A).at(B);
        double ans = help(A - 100, B, dp);
        ans += help(A - 75, B - 25, dp);
        ans += help(A - 50, B - 50, dp);
        ans += help(A - 25, B - 75, dp);
        return dp[A][B] = 0.25 * ans;
    }   
public:
    double soupServings(int n){
        if(n > 4750) return 1;
        unordered_map<int, unordered_map<int, double>> dp;
        return help(n, n, dp);
    }
};

664. Strange Printer
There is a strange printer with the following two special properties:

The printer can only print a sequence of the same character each time.
At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.
Given a string s, return the minimum number of turns the printer needed to print it.

 

Example 1:

Input: s = "aaabbb"
Output: 2
Explanation: Print "aaa" first and then print "bbb".
Example 2:

Input: s = "aba"
Output: 2
Explanation: Print "aaa" first and then print "b" from the second place of the string, which will cover the existing character 'a'.
 

Constraints:

1 <= s.length <= 100
s consists of lowercase English letters.

solution--
class Solution {
public:
    int strangePrinter(string s) {
        if(s.size()==0)return 0;
        vector<vector<int>> dp(s.size(),vector<int>(s.size(),0));
        for(int i=s.size()-1;i>=0;i--)
            for(int j=i;j<s.size();j++)
            {
                if(i==j)dp[i][j]=1;
                else
                {
                    int temp=dp[i][j-1]+1,m;
                    for(m=j-1;m>=i;m--)
                        if(s[m]==s[j])
                        {
                            if(m>0&&temp>dp[i][m-1]+dp[m][j-1])temp=dp[i][m-1]+dp[m][j-1];
                            else if(m==0)temp=dp[0][j-1];//for special cases
                        }
                    dp[i][j]=temp;
                }
            }
        return dp[0][s.size()-1];
    }
};


712. Minimum ASCII Delete Sum for Two Strings
Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings equal.

 

Example 1:

Input: s1 = "sea", s2 = "eat"
Output: 231
Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum.
Deleting "t" from "eat" adds 116 to the sum.
At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.
Example 2:

Input: s1 = "delete", s2 = "leet"
Output: 403
Explanation: Deleting "dee" from "delete" to turn the string into "let",
adds 100[d] + 101[e] + 101[e] to the sum.
Deleting "e" from "leet" adds 101[e] to the sum.
At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403.
If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.
 

Constraints:

1 <= s1.length, s2.length <= 1000
s1 and s2 consist of lowercase English letters.

solution--
class Solution {
public:
    int minimumDeleteSum(string s1, string s2) {
        int m = s1.size(), n = s2.size();
        vector<int> dp(n+1, 0);
        for (int j = 1; j <= n; j++)
            dp[j] = dp[j-1]+s2[j-1];
        for (int i = 1; i <= m; i++) {
            int t1 = dp[0];
            dp[0] += s1[i-1];
            for (int j = 1; j <= n; j++) {
                int t2 = dp[j];
                dp[j] = s1[i-1] == s2[j-1]? t1:min(dp[j]+s1[i-1], dp[j-1]+s2[j-1]);
                t1 = t2;
            }
        }
        return dp[n];
    }
};

77. Combinations
Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].

You may return the answer in any order.

 

Example 1:

Input: n = 4, k = 2
Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
Explanation: There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.
Example 2:

Input: n = 1, k = 1
Output: [[1]]
Explanation: There is 1 choose 1 = 1 total combination.
 

Constraints:

1 <= n <= 20
1 <= k <= n

Solution--
class{
public:
void util(int start, int n, int k, vector<int> &v, vector<vector<int>> &ans){
    
    if(v.size() == k){
        ans.push_back(v);
        return;
    }
    
    for(int i = start; i <= n; i++){
        v.push_back(i);
        util(i + 1, n, k, v, ans);
        v.pop_back();
    }
    
}

vector<vector<int>> combine(int n, int k) {
    
    vector<vector<int>> ans;
    vector<int> v;
    
    util(1, n, k, v, ans);
    
    return ans;
    
}
};

17. Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.

A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.


 

Example 1:

Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]
Example 2:

Input: digits = ""
Output: []
Example 3:

Input: digits = "2"
Output: ["a","b","c"]
 

Constraints:

0 <= digits.length <= 4
digits[i] is a digit in the range ['2', '9'].

solution--
class Solution {
public:
    void solve(string digits , string output , int index , vector<string>& ans , string mapping[]){
       
     //base case
      if(index >= digits.length()){
          ans.push_back(output);
          return ;
      }    
      int number = digits[index] - '0';
      string value = mapping[number];     
      for(int i = 0 ; i<value.length() ; i++){
         output.push_back(value[i]);
          solve(digits , output , index+1 , ans , mapping);
          output.pop_back();
      }     
  }
vector<string> letterCombinations(string digits) {
    
    vector<string> ans;
    if(digits.length() == 0){
        return ans;
    }   
     string output = "";
     int index = 0;
     string mapping[10] = {"" , "","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};     
    solve(digits , output , index , ans , mapping);
        return ans;
}
};

139. Word Break
Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.

Note that the same word in the dictionary may be reused multiple times in the segmentation.

 

Example 1:

Input: s = "leetcode", wordDict = ["leet","code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
Example 2:

Input: s = "applepenapple", wordDict = ["apple","pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
Note that you are allowed to reuse a dictionary word.
Example 3:

Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: false
 

Constraints:

1 <= s.length <= 300
1 <= wordDict.length <= 1000
1 <= wordDict[i].length <= 20
s and wordDict[i] consist of only lowercase English letters.
All the strings of wordDict are unique.

solution--
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        int n = s.length();
        vector<bool> dp(n, 0);
        for (int i = -1; i < n; i++) {
            if (i >= 0 && dp[i] == false) {
                continue;
            }
            for (auto word: wordDict) {
                int j = 0;
                while (j < word.length()
                    && i + 1 + j < n
                    && word[j] == s[i + 1 + j]) {
                        j++;
                }
                if (j == word.length()) {
                    dp[i + word.length()] = true;
                }
            }
        }
        return dp[n - 1];
    }
};

95. Unique Binary Search Trees II
Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.

 

Example 1:


Input: n = 3
Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
Example 2:

Input: n = 1
Output: [[1]]
 

Constraints:

1 <= n <= 8

solution--
class Solution {
public:
vector<TreeNode*>ans;
set<vector<int>>st;
vector<int>preo;

// preorder
void traverse(TreeNode*root)
{
   if(root==NULL)
    return;
    preo.push_back(root->val);
    traverse(root->left);
    traverse(root->right);  
}
bool check(TreeNode*ptr)
{
  // return true if it is unique
   vector<int>preorder;
   preo=preorder;//reset the preo since it is global
   traverse(ptr);
   for(int i=0;i<preo.size();i++)
   cout<<preo[i]<<" ";
   cout<<endl;
   if(st.find(preo)==st.end())
   {
     st.insert(preo);
   return true;
   }
   return false;
}

//creating bst

TreeNode*bst(TreeNode*root,int key)
{
    if(root==NULL)
    {
      TreeNode*temp=new TreeNode(key);
     temp->left=NULL;
     temp->right=NULL;
     return temp;
    }

  if(key>root->val)
    root->right=bst(root->right,key);
  else
    root->left=bst(root->left,key);

  return root;
}

void create_bst(vector<int>&nums)
{
TreeNode*root=new TreeNode(nums[0]);//make root
root->left=NULL;
root->right=NULL;

  for(int i=1;i<nums.size();i++)
   root=bst(root,nums[i]);//get always updated root

   if(check(root))
    ans.push_back(root);
}

//make all possible combination..permutation
void func(vector<int>&nums,int index)
{
  if(index==nums.size())
  {
      create_bst(nums);
      return;
  }
  for(int i=index;i<nums.size();i++)
  {
      swap(nums[index],nums[i]);
      func(nums,index+1);
      swap(nums[index],nums[i]);
  }
}
    vector<TreeNode*> generateTrees(int n) {
        vector<int>nums;
        for(int i=1;i<=n;i++)
         nums.push_back(i);
         func(nums,0);
         return ans;
    }
};

/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func dp(l, r int, memo *map[[2]int][]*TreeNode) []*TreeNode {
  /*
  * l: left bound
  * r: right bound
  * memo: memorize the answer of sub problems
  */
  if l > r {
    // no child
    return append(make([]*TreeNode, 0), nil)
  }
  key := [2]int{l, r}
  if v, ok := (*memo)[key]; ok {
    // if this sub-problem has solved
    return v
  }

  // solve
  ret := make([]*TreeNode, 0)
  for i := l; i <= r; i++ { // every number within boundary
    left_part := dp(l, i-1, memo)
    right_part := dp(i+1, r, memo)
    for j := 0; j < len(left_part); j++ {
      for k := 0; k < len(right_part); k++ {
        // traverse all combinations
        root := &TreeNode{
          Val: i, // i is root
          Left: left_part[j],
          Right: right_part[k],
          }
        ret = append(ret, root)
      }
    }
  }
  (*memo)[key] = ret // memorize
  return ret
}

74. Search a 2D Matrix

You are given an m x n integer matrix matrix with the following two properties:

Each row is sorted in non-decreasing order.
The first integer of each row is greater than the last integer of the previous row.
Given an integer target, return true if target is in matrix or false otherwise.

You must write a solution in O(log(m * n)) time complexity.

 

Example 1:


Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true
Example 2:


Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 100
-104 <= matrix[i][j], target <= 104


class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int rows = matrix.size(),
			cols = matrix[0].size(),
            row = 0, col = cols - 1;
			
        while (row < rows && col > -1) {
            int cur = matrix[row][col];
            if (cur == target) return true;
            if (target > cur) row++;
            else col--;
        }
        
        return false;
    }
};
