date==14/5/23
Maximize Score After N Operations

You are given nums, an array of positive integers of size 2 * n. You must perform n operations on this array.

In the ith operation (1-indexed), you will:

Choose two elements, x and y.
Receive a score of i * gcd(x, y).
Remove x and y from nums.
Return the maximum score you can receive after performing n operations.

The function gcd(x, y) is the greatest common divisor of x and y.

 

Example 1:

Input: nums = [1,2]
Output: 1
Explanation: The optimal choice of operations is:
(1 * gcd(1, 2)) = 1
Example 2:

Input: nums = [3,4,6,8]
Output: 11
Explanation: The optimal choice of operations is:
(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11
Example 3:

Input: nums = [1,2,3,4,5,6]
Output: 14
Explanation: The optimal choice of operations is:
(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14
 

Constraints:

1 <= n <= 7
nums.length == 2 * n
1 <= nums[i] <= 106
solution:
class Solution {
public:
    int maxScore(vector<int>& nums) {
        int n = nums.size();
        
        
        vector<vector<int>> gcdMatrix(n, vector<int>(n));
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                gcdMatrix[i][j] = gcdMatrix[j][i] = gcd(nums[i], nums[j]);
            }
        }
        
        
        vector<int> dp(1 << n);
        
        
        for (int state = 1; state < (1 << n); state++) {
            
            int cnt = __builtin_popcount(state);
            
            
            if (cnt % 2 == 1) {
                continue;
            }
            
            
            for (int i = 0; i < n; i++) {
                if ((state & (1 << i)) == 0) {
                    continue;
                }
                for (int j = i + 1; j < n; j++) {
                    if ((state & (1 << j)) == 0) {
                        continue;
                    }
                    int nextState = state ^ (1 << i) ^ (1 << j);
                    dp[state] = max(dp[state], dp[nextState] + cnt / 2 * gcdMatrix[i][j]);
                }
            }
        }
        
        return dp[(1 << n) - 1];
    }
    
    int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
};
day 4 15-05-23
1721. Swapping Nodes in a Linked List
Medium
4.3K
143
Companies
You are given the head of a linked list, and an integer k.

Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).

 

Example 1:


Input: head = [1,2,3,4,5], k = 2
Output: [1,4,3,2,5]
Example 2:

Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5
Output: [7,9,6,6,8,7,3,0,9,5]
solution:-
class Solution {
public:
    ListNode* swapNodes(ListNode* head, int k) {
        ListNode *left_ptr = head, *right_ptr = head;
        for (int i = 0; i < k-1; i++) {
            right_ptr = right_ptr->next;
        }
        
        ListNode *end_ptr = right_ptr;
        while (right_ptr->next) {
            left_ptr = left_ptr->next;
            right_ptr = right_ptr->next;
        }
        
        swap(end_ptr->val, left_ptr->val);
        
        return head;
    }
};

day -8-7-2023
2551. Put Marbles in Bags
Hard

925

34

Add to List

Share
You have k bags. You are given a 0-indexed integer array weights where weights[i] is the weight of the ith marble. You are also given the integer k.

Divide the marbles into the k bags according to the following rules:

No bag is empty.
If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.
If a bag consists of all the marbles with an index from i to j inclusively, then the cost of the bag is weights[i] + weights[j].
The score after distributing the marbles is the sum of the costs of all the k bags.

Return the difference between the maximum and minimum scores among marble distributions.

 

Example 1:

Input: weights = [1,3,5,1], k = 2
Output: 4
Explanation: 
The distribution [1],[3,5,1] results in the minimal score of (1+1) + (3+1) = 6. 
The distribution [1,3],[5,1], results in the maximal score of (1+3) + (5+1) = 10. 
Thus, we return their difference 10 - 6 = 4.
Example 2:

Input: weights = [1, 3], k = 2
Output: 0
Explanation: The only distribution possible is [1],[3]. 
Since both the maximal and minimal score are the same, we return 0.
 

Constraints:

1 <= k <= weights.length <= 105
1 <= weights[i] <= 109
//greedy algorithm 
class Solution {
public:
    long long putMarbles(vector<int>& weights, int k) {
        int n=weights.size();
        vector<int>arr(n-1);
        for(int i=0;i<n-1;i++){
            arr[i]=weights[i]+weights[i+1];
        }
        sort(arr.begin(),arr.end());
        long long ans=0;
        k--;
        n--;
        for(int i=0;i<k;i++){
            ans-=arr[i];
            ans+=arr[n-i-1];
        }
        return ans;
    }
};
//priority queue algorithm
class Solution {
public:
    long long putMarbles(vector<int>& weights, int k) {
priority_queue<int> po;
priority_queue<int,vector<int>,greater<int>> po2;
long long ii=0;
for(int i=0;i+1<weights.size();i++){
    po.push(weights[i]+weights[i+1]);
    po2.push(weights[i]+weights[i+1]);
}
long long ii2=0;
while(k>1){
ii2+=(po.top()-po2.top());
po.pop();
po2.pop();
k--;
}
return ii2;
    }
};

9-7-2023
2272. Substring With Largest Variance
The variance of a string is defined as the largest difference between the number of occurrences of any 2 characters present in the string. Note the two characters may or may not be the same.

Given a string s consisting of lowercase English letters only, return the largest variance possible among all substrings of s.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: s = "aababbb"
Output: 3
Explanation:
All possible variances along with their respective substrings are listed below:
- Variance 0 for substrings "a", "aa", "ab", "abab", "aababb", "ba", "b", "bb", and "bbb".
- Variance 1 for substrings "aab", "aba", "abb", "aabab", "ababb", "aababbb", and "bab".
- Variance 2 for substrings "aaba", "ababbb", "abbb", and "babb".
- Variance 3 for substring "babbb".
Since the largest possible variance is 3, we return it.
Example 2:

Input: s = "abcde"
Output: 0
Explanation:
No letter occurs more than once in s, so the variance of every substring is 0.
 

Constraints:

1 <= s.length <= 104
s consists of lowercase English letters.

solution--
class Solution {
public:
    int largestVariance(string s) {
        vector<int> freq(26,0);
        for(int i=0;i<s.length();i++)
            freq[s[i]-'a']++;
        int ans=0;
        for(int i=0;i<26;i++){
            for(int j=0;j<26;j++){
                if(i==j || freq[i]==0 || freq[j]==0) continue;
                int c1=0,c2=0,rmc=freq[j];
                for(auto ch: s){
                    if(ch=='a'+i) c1++;
                    if(ch=='a'+j){
                        c2++;
                        rmc--;
                    }
                    if(c2>0) ans=max(ans,c1-c2);
                    if(c1<c2 && rmc>0){
                        c1=0;
                        c2=0;
                    }
                }
            }
        }
        return ans;
    }
};

10-7-2023
111. Minimum Depth of Binary Tree
Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

Note: A leaf is a node with no children.

 

Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: 2
Example 2:

Input: root = [2,null,3,null,4,null,5,null,6]
Output: 5
 

Constraints:

The number of nodes in the tree is in the range [0, 105].
-1000 <= Node.val <= 1000

solution--by using recursion solution of dfs--
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root==NULL) return 0;
        if(root->left==NULL || root->right== NULL) return 1+minDepth(root->right)+minDepth(root->left);
        else return (1+min(minDepth(root->left),minDepth(root->right)));
    }
};


13-7-2023
802. Find Eventual Safe States
There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].

A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node).

Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.

 

Example 1:

Illustration of graph
Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]
Output: [2,4,5,6]
Explanation: The given graph is shown above.
Nodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.
Every path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.
Example 2:

Input: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
Output: [4]
Explanation:
Only node 4 is a terminal node, and every path starting at node 4 leads to node 4.

class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int>adj[n];
        vector<int>indegree(n,0);

        for(int i=0;i<n;i++){
            for(auto it:graph[i]){
                adj[it].push_back(i);
                indegree[i]++;
            }
        }
        queue<int>q;
        for(int i=0;i<n;i++){
            if(indegree[i]==0){
                q.push(i);
            }
        }
        vector<int>safeNodes;
        while(!q.empty()){
            int node = q.front();
            q.pop();
            safeNodes.push_back(node);
            for(auto it:adj[node]){
                indegree[it]--;
                if(indegree[it]==0){
                    q.push(it);
                }
            }
        }

        sort(safeNodes.begin(),safeNodes.end());
        return safeNodes;
    }
};

13-07-23
207. Course Schedule
There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return true if you can finish all courses. Otherwise, return false.

 

Example 1:

Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
Example 2:

Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
 

Constraints:

1 <= numCourses <= 2000
0 <= prerequisites.length <= 5000
prerequisites[i].length == 2
0 <= ai, bi < numCourses

377. Combination Sum IV
Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.

The test cases are generated so that the answer can fit in a 32-bit integer.

 

Example 1:

Input: nums = [1,2,3], target = 4
Output: 7
Explanation:
The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
Note that different sequences are counted as different combinations.
Example 2:

Input: nums = [9], target = 3
Output: 0
 

Constraints:

1 <= nums.length <= 200
1 <= nums[i] <= 1000
All the elements of nums are unique.
1 <= target <= 1000
 

Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?

class Solution {
public:

    int combinations(int currSum,vector<int>& nums, int target,vector<int>&dp)
    {
        if(currSum == target)
        {
            return 1;
        }
        if(currSum > target)
        {
            return 0;
        }
        if(dp[currSum] != -1)
        {
            return dp[currSum];
        }

        int cnt =0;

        for(int i =0 ; i<nums.size();i++)
        {
            cnt += combinations(currSum + nums[i],nums,target,dp);
        }

        return dp[currSum] = cnt;
    }


    int combinationSum4(vector<int>& nums, int target) 
    {
        vector<int>dp(target+1,-1);
        return combinations(0,nums,target,dp);
    }
};
All the pairs prerequisites[i] are unique.
solution--
class Solution {
public:
bool dfs(vector<int> * list,vector<int> &visited,int source){
    if(visited[source])
    {
    return false;

    }
    visited[source]=true;
    for(auto child: list[source]){
        if(visited[child]!=2){

        
        if(dfs(list,visited,child)==false){
            return false;
        }
        }
    }
    visited[source]=2;
    return true;
}
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
     int n=numCourses;
     vector<int> list [n];
     for(int i=0;i<prerequisites.size();i++){
             list[prerequisites[i][0]].push_back(prerequisites[i][1]);
         
     }   
     vector<int> visited(n+1,false);
     for(int i=0;i<n;i++){
         if(!visited[i]){
             if(dfs(list,visited,i)==false){
                 return false;
             }
         }
     }
     return true;
    }
};

1218. Longest Arithmetic Subsequence of Given Difference
Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference.

A subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements.

 

Example 1:

Input: arr = [1,2,3,4], difference = 1
Output: 4
Explanation: The longest arithmetic subsequence is [1,2,3,4].
Example 2:

Input: arr = [1,3,5,7], difference = 1
Output: 1
Explanation: The longest arithmetic subsequence is any single element.
Example 3:

Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2
Output: 4
Explanation: The longest arithmetic subsequence is [7,5,3,1].
 

Constraints:

1 <= arr.length <= 105
-104 <= arr[i], difference <= 104

solution--
class Solution {
public:
    int longestSubsequence(vector<int>& arr, int difference) {
        unordered_map<int, int> dp;
        int maxLength = 0;

        for (int num : arr) {
            int prevNum = num - difference;
            if (dp.count(prevNum)) {
                dp[num] = dp[prevNum] + 1;
            } else {
                dp[num] = 1;
            }
            maxLength = max(maxLength, dp[num]);
        }

        return maxLength;  
    }
};


1125. Smallest Sufficient Team
In a project, you have a list of required skills req_skills, and a list of people. The ith person people[i] contains a list of skills that the person has.

Consider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.

For example, team = [0, 1, 3] represents the people with skills people[0], people[1], and people[3].
Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.

It is guaranteed an answer exists.

 

Example 1:

Input: req_skills = ["java","nodejs","reactjs"], people = [["java"],["nodejs"],["nodejs","reactjs"]]
Output: [0,2]
Example 2:

Input: req_skills = ["algorithms","math","java","reactjs","csharp","aws"], people = [["algorithms","math","java"],["algorithms","math","reactjs"],["java","csharp","aws"],["reactjs","csharp"],["csharp","math"],["aws","java"]]
Output: [1,2]
 

Constraints:

1 <= req_skills.length <= 16
1 <= req_skills[i].length <= 16
req_skills[i] consists of lowercase English letters.
All the strings of req_skills are unique.
1 <= people.length <= 60
0 <= people[i].length <= 16
1 <= people[i][j].length <= 16
people[i][j] consists of lowercase English letters.
All the strings of people[i] are unique.
Every skill in people[i] is a skill in req_skills.
It is guaranteed a sufficient team exists.

solution--
class Solution {
public:

    int countBits(long long x){
     // counts the number of set bits in a long long int
        int count=0;
        for(int i=0;i<64;i++){
            if(x&(1LL<<i)) count++;
        }
        return count;
    }
    long long findMin(int i,int skills,int allSkills,vector<int>&peo,vector<vector<long long>>&dp){
      if(i==peo.size()){
             if(skills!=allSkills) {
                return (1LL<<i)-1LL;
             }
             return 0LL;
         }
         if(dp[i][skills]!=-1) return dp[i][skills];
         int temp=skills;
         long long notPick=findMin(i+1,skills,allSkills,peo,dp);
         temp|=peo[i];
         if(temp==skills) return notPick;
         long long pick=findMin(i+1,temp,allSkills,peo,dp);
        
         pick|=(1LL<<i);
        int x=countBits(pick);
        int y=countBits(notPick);
        if(x<y) return dp[i][skills]=pick;
        return dp[i][skills]=notPick;
         
         
    }
    vector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) {
        map<string,int>m;
        int n=req_skills.size();
        for(int i=0;i<n;i++){
            m[req_skills[i]]=i;
        }
        vector<int>peo(people.size(),0);
        for(int i=0;i<peo.size();i++){
            for(auto str:people[i]){
                peo[i]|=(1<<m[str]);
            }
        }
        
        int allSkills=(1<<n)-1;
        
             vector<vector<long long>>dp(peo.size(),vector<long long>(allSkills+1,-1));
        long long ans= findMin(0,0,allSkills,peo,dp);
        vector<int>res;
        for(int i=0;i<64;i++){
            if(ans&(1LL<<i)) res.push_back(i);
        }
   
        return res;
    }
};

445. Add Two Numbers II
You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

 

Example 1:


Input: l1 = [7,2,4,3], l2 = [5,6,4]
Output: [7,8,0,7]
Example 2:

Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [8,0,7]
Example 3:

Input: l1 = [0], l2 = [0]
Output: [0]
 

Constraints:

The number of nodes in each linked list is in the range [1, 100].
0 <= Node.val <= 9
It is guaranteed that the list represents a number that does not have leading zeros.

solution--
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

        stack<int> st1,st2;
        while(l1){ 
            st1.push(l1->val);
            l1 = l1->next;
        }
        // cout<<endl;
        while(l2){ 
            st2.push(l2->val);
            l2 = l2->next;
        }

        ListNode* result = NULL;

        int carry = 0;

        while(!st1.empty() || !st2.empty() || carry != 0){
            int num1 = ( !st1.empty() )? st1.top(): 0;
            int num2 = ( !st2.empty() )? st2.top(): 0;

            int sum = num1 + num2 + carry;
            carry = sum / 10;
            int rem = sum%10;

            ListNode* newNode = new ListNode(rem);
            newNode->next = result;
            result = newNode;

            if( !st1.empty() ) st1.pop();
            if( !st2.empty() ) st2.pop();

        }

        return result;
    }
};

435. Non-overlapping Intervals
Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.

 

Example 1:

Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
Example 2:

Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
Example 3:

Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
 

Constraints:

1 <= intervals.length <= 105
intervals[i].length == 2
-5 * 104 <= starti < endi <= 5 * 104

solution--
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        int result = 0;

        sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {
            return a[0] < b[0];
        }); 

        for (int i = 0; i < intervals.size()-1; i++) {
            // no overlap
            if (intervals[i][1] <= intervals[i+1][0]) continue;
            // overlap
            intervals[i+1][0] = intervals[i][0];
            intervals[i+1][1] = min(intervals[i][1], intervals[i+1][1]);
            result++;
        }

        return result;
    }
};

735. Asteroid Collision
We are given an array asteroids of integers representing asteroids in a row.

For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.

Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.

 

Example 1:

Input: asteroids = [5,10,-5]
Output: [5,10]
Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.
Example 2:

Input: asteroids = [8,-8]
Output: []
Explanation: The 8 and -8 collide exploding each other.
Example 3:

Input: asteroids = [10,2,-5]
Output: [10]
Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.
 

Constraints:

2 <= asteroids.length <= 104
-1000 <= asteroids[i] <= 1000
asteroids[i] != 0

solution--
class Solution {
public:
    vector<int> asteroidCollision(vector<int>& asteroids) {
                stack<pair<int,char>>st;
        for(int i=0;i<asteroids.size();i++)
        {
            char ch = 'R';
            if(asteroids[i]<0)ch='L';

            if(st.empty())
            {
                st.push({asteroids[i],ch});
                continue;
            }

            if(st.top().second==ch)st.push({asteroids[i],ch});
            else
            {
                if(ch=='R')st.push({asteroids[i],ch});
                else
                {
                    pair<int,char>t=st.top();
                    int flag=1;
                    while(t.second!=ch)
                    {
                        
                        if(t.first == abs(asteroids[i]))
                            {st.pop(),flag=0;break;}
                        else if(t.first<abs(asteroids[i]))
                            st.pop();
                        else 
                            {flag=0;break;}

                        if(st.empty())
                            break;
                        t = st.top();
                     
                    }
                    
                    if(flag)
                        st.push({asteroids[i],ch});
                }
            }
        }
        vector<int>ans;
        int s = st.size();
        for(int i=0;i<s;i++)
        {ans.push_back(st.top().first);st.pop();}

        reverse(ans.begin(),ans.end());
        return ans;
    }
};

673. Number of Longest Increasing Subsequence
Given an integer array nums, return the number of longest increasing subsequences.

Notice that the sequence has to be strictly increasing.

 

Example 1:

Input: nums = [1,3,5,4,7]
Output: 2
Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].
Example 2:

Input: nums = [2,2,2,2,2]
Output: 5
Explanation: The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.
 

Constraints:

1 <= nums.length <= 2000
-106 <= nums[i] <= 106

solution--

class Solution {
public:
    int findNumberOfLIS(vector<int>& nums) {
        int n = nums.size(), lenLis = 1;
        vector<int> dp(n, 1), cnt(n, 1);
        // dp[i] = length of LIS ending at index i
        // cnt[i] = count of LIS of length dp[i] ending at index i
    
        for(int i=0; i<n; i++){
            for(int prev = 0; prev < i; prev++ ){
                if( nums[prev] < nums[i] && dp[prev] + 1 > dp[i] ){
                    dp[i] = dp[prev] + 1; 
                    cnt[i] = cnt[prev];
                }
                else if( nums[prev] < nums[i] && dp[prev] + 1 == dp[i] ) cnt[i] += cnt[prev];
            } 
            lenLis = max(lenLis, dp[i]);
        }

        int ans = 0;
        for(int i=0; i<n; i++ ) ans += (dp[i] == lenLis ? cnt[i] : 0);
        return ans;
    }
};

688. Knight Probability in Chessboard
On an n x n chessboard, a knight starts at the cell (row, column) and attempts to make exactly k moves. The rows and columns are 0-indexed, so the top-left cell is (0, 0), and the bottom-right cell is (n - 1, n - 1).

A chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.


Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.

The knight continues moving until it has made exactly k moves or has moved off the chessboard.

Return the probability that the knight remains on the board after it has stopped moving.

 

Example 1:

Input: n = 3, k = 2, row = 0, column = 0
Output: 0.06250
Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.
From each of those positions, there are also two moves that will keep the knight on the board.
The total probability the knight stays on the board is 0.0625.
Example 2:

Input: n = 1, k = 0, row = 0, column = 0
Output: 1.00000
 

Constraints:

1 <= n <= 25
0 <= k <= 100
0 <= row, column <= n - 1

solution--
class Solution {
public:
    double knightProbability(int n, int k, int row, int column) {
        int moves[8][2]={{-2,-1},{-1,-2},{1,-2},{2,-1},{1,2},{2,1},{-1,2},{-2,1}};
        vector<vector<double>> v1(n,vector<double>(n,0));
        vector<vector<double>> v2(n,vector<double>(n,0));
        vector<vector<double>> &v = v1;
        vector<vector<double>> &vn = v2;
        v[row][column]=1;
        for(; k>0; k--)
        {
            for(int i=0; i<n; i++)
            {
                for(int j=0; j<n; j++)
                {
                    double f=v[i][j]/8;  
                    v[i][j] = 0;         
                    for(int l=0; l<8; l++)
                    {
                        int y=i+moves[l][0];
                        int x=j+moves[l][1];
                        if (y >=0 && y <n && x>=0 && x<n)
                            vn[y][x] += f;  
                    }
                }

            }
            swap(v,vn);
        }
        double ans = 0;
        for(int i=0; i<n; i++)
            for(int j=0; j<n; j++)
               ans += v[i][j];  
        
        return ans;

    }
};

894. All Possible Full Binary Trees
Given an integer n, return a list of all possible full binary trees with n nodes. Each node of each tree in the answer must have Node.val == 0.

Each element of the answer is the root node of one possible tree. You may return the final list of trees in any order.

A full binary tree is a binary tree where each node has exactly 0 or 2 children.

 

Example 1:


Input: n = 7
Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]
Example 2:

Input: n = 3
Output: [[0,0,0]]

solution--
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
       
      vector<TreeNode*> solve(int n){
            vector<TreeNode*> res;
            if(n%2==0)return res;
             if(n==1) {
                 TreeNode* root= new TreeNode(0);
                 res.push_back(root);
                 return res;
             }
            for(int i=1;i<=n-2;i+=2){
                vector<TreeNode*> l= solve(i);
                vector<TreeNode*> r= solve(n-i-1);
                for(int k=0;k<l.size();k++){
                    for(int p=0;p<r.size();p++){
                        TreeNode* root=new TreeNode(0);
                        root->left=l[k];
                        root->right=r[p];
                        res.push_back(root);
                    }
                }
            }
          return res;
      }
    vector<TreeNode*> allPossibleFBT(int n) {
          
      
        return solve(n) ;
    }
};

50. Pow(x, n)
Implement pow(x, n), which calculates x raised to the power n (i.e., xn).

 

Example 1:

Input: x = 2.00000, n = 10
Output: 1024.00000
Example 2:

Input: x = 2.10000, n = 3
Output: 9.26100
Example 3:

Input: x = 2.00000, n = -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
 

Constraints:

-100.0 < x < 100.0
-231 <= n <= 231-1
n is an integer.
Either x is not zero or n > 0.
-104 <= xn <= 104

solution---
class Solution {
public:
    double myPow(double x, int n) {
        if(n==0) return 1;
        if(n<0) {
            n = abs(n);
            x = 1/x;
        }
        if(n%2==0){
            return myPow(x*x, n/2);
        }
        else{
            return x*myPow(x, n-1);
        }
    }
};


852. Peak Index in a Mountain Array


Add to List
An array arr a mountain if the following properties hold:

arr.length >= 3
There exists some i with 0 < i < arr.length - 1 such that:
arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
Given a mountain array arr, return the index i such that arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1].

You must solve it in O(log(arr.length)) time complexity.

 

Example 1:

Input: arr = [0,1,0]
Output: 1
Example 2:

Input: arr = [0,2,1,0]
Output: 1
Example 3:

Input: arr = [0,10,5,2]
Output: 1
 

Constraints:

3 <= arr.length <= 105
0 <= arr[i] <= 106
arr is guaranteed to be a mountain array.


solution--
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
      int low = 0, high = arr.size()-1,mid;
       while(low<high){
           mid = (low+high)/2;
           if(arr[mid]<arr[mid+1]){
               low = mid+1;
           }else{
               high = mid;
           }
       }

       return low;
    }
};

1870. Minimum Speed to Arrive on Time
Medium

1930

226

Add to List

Share
You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.

Each train can only depart at an integer hour, so you may need to wait in between each train ride.

For example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.
Return the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.

Tests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.

 

Example 1:

Input: dist = [1,3,2], hour = 6
Output: 1
Explanation: At speed 1:
- The first train ride takes 1/1 = 1 hour.
- Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.
- Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.
- You will arrive at exactly the 6 hour mark.
Example 2:

Input: dist = [1,3,2], hour = 2.7
Output: 3
Explanation: At speed 3:
- The first train ride takes 1/3 = 0.33333 hours.
- Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.
- Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.
- You will arrive at the 2.66667 hour mark.
Example 3:

Input: dist = [1,3,2], hour = 1.9
Output: -1
Explanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.
 

Constraints:

n == dist.length
1 <= n <= 105
1 <= dist[i] <= 105
1 <= hour <= 109
There will be at most two digits after the decimal point in hour.

solution--
class Solution {
public:
    int minSpeedOnTime(vector<int>& dist, double hour) {
        int start = 1, n = dist.size(), end = 1e9;
        int speed = -1;
        while(start<=end){
            int mid = end-(end-start)/2;
            double totalTimeTaken = 0;
            for(int i=0; i<n; i++){
                double timeTaken = (double)dist[i]/mid;
                if (i != n-1){
                    timeTaken = ceil(timeTaken);
                }
                totalTimeTaken += timeTaken;    
            }
            if (totalTimeTaken <= hour){
                speed = mid;
                end = mid-1;
            }else{
                start = mid+1;
            }
        }
        return speed;
    }
};

2141. Maximum Running Time of N Computers

You have n computers. You are given the integer n and a 0-indexed integer array batteries where the ith battery can run a computer for batteries[i] minutes. You are interested in running all n computers simultaneously using the given batteries.

Initially, you can insert at most one battery into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery any number of times. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.

Note that the batteries cannot be recharged.

Return the maximum number of minutes you can run all the n computers simultaneously.

 

Example 1:


Input: n = 2, batteries = [3,3,3]
Output: 4
Explanation: 
Initially, insert battery 0 into the first computer and battery 1 into the second computer.
After two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.
At the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.
By the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.
We can run the two computers simultaneously for at most 4 minutes, so we return 4.

Example 2:


Input: n = 2, batteries = [1,1,1,1]
Output: 2
Explanation: 
Initially, insert battery 0 into the first computer and battery 2 into the second computer. 
After one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. 
After another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.
We can run the two computers simultaneously for at most 2 minutes, so we return 2.
 

Constraints:

1 <= n <= batteries.length <= 105
1 <= batteries[i] <= 109


solution--
class Solution {
public:
    long long maxRunTime(int n, vector<int>& b) {
      if(n>b.size()) return -1;
      
      long long sum =0;
      priority_queue<int> maxh;
      for(auto i : b){
         sum+=i;
         maxh.push(i);
      }
      while(maxh.top()>sum/n){
          sum-=maxh.top();
          maxh.pop();
          n--;
      }
      return sum/n;
     
      
    }
};

486. Predict the Winner
You are given an integer array nums. Two players are playing a game with this array: player 1 and player 2.

Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of 0. At each turn, the player takes one of the numbers from either end of the array (i.e., nums[0] or nums[nums.length - 1]) which reduces the size of the array by 1. The player adds the chosen number to their score. The game ends when there are no more elements in the array.

Return true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. You may assume that both players are playing optimally.

 

Example 1:

Input: nums = [1,5,2]
Output: false
Explanation: Initially, player 1 can choose between 1 and 2. 
If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). 
So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. 
Hence, player 1 will never be the winner and you need to return false.
Example 2:

Input: nums = [1,5,233,7]
Output: true
Explanation: Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.
Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.
 

Constraints:

1 <= nums.length <= 20
0 <= nums[i] <= 107

solution--
class Solution {
public:

    int dp[21][21];
    int solve(int start, int end, vector<int>& nums) {
          if(dp[start][end]!=-1)
        {
            return dp[start][end];
        }
        if (start == end) {
            return nums[start];
        }
      
        int pickStart = nums[start] - solve(start + 1, end, nums);
        int pickEnd = nums[end] - solve(start, end - 1, nums);

        return dp[start][end]=max(pickStart, pickEnd);
    }

    bool PredictTheWinner(vector<int>& nums) {
        int start = 0;
        int end = nums.size() - 1;

        memset(dp,-1,sizeof(dp));

        return solve(start, end, nums) >= 0;
    }
};



// class Solution {
// public:
//     bool PredictTheWinner(int nums[]) {
// //         int n=nums.size();
// //         int player1=0,player2=0;
// //         sort(nums.begin(),nums.end());
// //         for(int i=0;i<=n-1;i++){
// //            if(i%2==0) player1+=nums[i];
// //            else player2+=nums[i];
// //         }
// //         if(player1<player2) return false;
        
// //         return true;
        
//         recursive(nums,0,nums.length-1)>=0;
        
//     }
//     public: int recursive(int nums[],int start, int end){
        
//         if(start==end) return nums[start];
        
//         int left = nums[start] - recursive(nums,start+1,end);
//         int right = nums[end] - recursive(nums,start,end+1);
        
//         return Math.max(left,right);
        
//     }
// };

808. Soup Servings
There are two types of soup: type A and type B. Initially, we have n ml of each type of soup. There are four kinds of operations:

Serve 100 ml of soup A and 0 ml of soup B,
Serve 75 ml of soup A and 25 ml of soup B,
Serve 50 ml of soup A and 50 ml of soup B, and
Serve 25 ml of soup A and 75 ml of soup B.
When we serve some soup, we give it to someone, and we no longer have it. Each turn, we will choose from the four operations with an equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as possible. We stop once we no longer have some quantity of both types of soup.

Note that we do not have an operation where all 100 ml's of soup B are used first.

Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time. Answers within 10-5 of the actual answer will be accepted.

 

Example 1:

Input: n = 50
Output: 0.62500
Explanation: If we choose the first two operations, A will become empty first.
For the third operation, A and B will become empty at the same time.
For the fourth operation, B will become empty first.
So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.
Example 2:

Input: n = 100
Output: 0.71875
 

Constraints:

0 <= n <= 109

class Solution {
private:
     double help(int A, int B, unordered_map<int, unordered_map<int, double>> &dp){
        if(A <= 0) return B <= 0 ? 0.5 : 1.0;
        if(B <= 0) return 0.0;
        if(dp.find(A) != dp.end() && dp.at(A).find(B) != dp.at(A).end())
            return dp.at(A).at(B);
        double ans = help(A - 100, B, dp);
        ans += help(A - 75, B - 25, dp);
        ans += help(A - 50, B - 50, dp);
        ans += help(A - 25, B - 75, dp);
        return dp[A][B] = 0.25 * ans;
    }   
public:
    double soupServings(int n){
        if(n > 4750) return 1;
        unordered_map<int, unordered_map<int, double>> dp;
        return help(n, n, dp);
    }
};

664. Strange Printer
There is a strange printer with the following two special properties:

The printer can only print a sequence of the same character each time.
At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.
Given a string s, return the minimum number of turns the printer needed to print it.

 

Example 1:

Input: s = "aaabbb"
Output: 2
Explanation: Print "aaa" first and then print "bbb".
Example 2:

Input: s = "aba"
Output: 2
Explanation: Print "aaa" first and then print "b" from the second place of the string, which will cover the existing character 'a'.
 

Constraints:

1 <= s.length <= 100
s consists of lowercase English letters.

solution--
class Solution {
public:
    int strangePrinter(string s) {
        if(s.size()==0)return 0;
        vector<vector<int>> dp(s.size(),vector<int>(s.size(),0));
        for(int i=s.size()-1;i>=0;i--)
            for(int j=i;j<s.size();j++)
            {
                if(i==j)dp[i][j]=1;
                else
                {
                    int temp=dp[i][j-1]+1,m;
                    for(m=j-1;m>=i;m--)
                        if(s[m]==s[j])
                        {
                            if(m>0&&temp>dp[i][m-1]+dp[m][j-1])temp=dp[i][m-1]+dp[m][j-1];
                            else if(m==0)temp=dp[0][j-1];//for special cases
                        }
                    dp[i][j]=temp;
                }
            }
        return dp[0][s.size()-1];
    }
};


712. Minimum ASCII Delete Sum for Two Strings
Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings equal.

 

Example 1:

Input: s1 = "sea", s2 = "eat"
Output: 231
Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum.
Deleting "t" from "eat" adds 116 to the sum.
At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.
Example 2:

Input: s1 = "delete", s2 = "leet"
Output: 403
Explanation: Deleting "dee" from "delete" to turn the string into "let",
adds 100[d] + 101[e] + 101[e] to the sum.
Deleting "e" from "leet" adds 101[e] to the sum.
At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403.
If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.
 

Constraints:

1 <= s1.length, s2.length <= 1000
s1 and s2 consist of lowercase English letters.

solution--
class Solution {
public:
    int minimumDeleteSum(string s1, string s2) {
        int m = s1.size(), n = s2.size();
        vector<int> dp(n+1, 0);
        for (int j = 1; j <= n; j++)
            dp[j] = dp[j-1]+s2[j-1];
        for (int i = 1; i <= m; i++) {
            int t1 = dp[0];
            dp[0] += s1[i-1];
            for (int j = 1; j <= n; j++) {
                int t2 = dp[j];
                dp[j] = s1[i-1] == s2[j-1]? t1:min(dp[j]+s1[i-1], dp[j-1]+s2[j-1]);
                t1 = t2;
            }
        }
        return dp[n];
    }
};

77. Combinations
Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].

You may return the answer in any order.

 

Example 1:

Input: n = 4, k = 2
Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
Explanation: There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.
Example 2:

Input: n = 1, k = 1
Output: [[1]]
Explanation: There is 1 choose 1 = 1 total combination.
 

Constraints:

1 <= n <= 20
1 <= k <= n

Solution--
class{
public:
void util(int start, int n, int k, vector<int> &v, vector<vector<int>> &ans){
    
    if(v.size() == k){
        ans.push_back(v);
        return;
    }
    
    for(int i = start; i <= n; i++){
        v.push_back(i);
        util(i + 1, n, k, v, ans);
        v.pop_back();
    }
    
}

vector<vector<int>> combine(int n, int k) {
    
    vector<vector<int>> ans;
    vector<int> v;
    
    util(1, n, k, v, ans);
    
    return ans;
    
}
};

17. Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.

A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.


 

Example 1:

Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]
Example 2:

Input: digits = ""
Output: []
Example 3:

Input: digits = "2"
Output: ["a","b","c"]
 

Constraints:

0 <= digits.length <= 4
digits[i] is a digit in the range ['2', '9'].

solution--
class Solution {
public:
    void solve(string digits , string output , int index , vector<string>& ans , string mapping[]){
       
     //base case
      if(index >= digits.length()){
          ans.push_back(output);
          return ;
      }    
      int number = digits[index] - '0';
      string value = mapping[number];     
      for(int i = 0 ; i<value.length() ; i++){
         output.push_back(value[i]);
          solve(digits , output , index+1 , ans , mapping);
          output.pop_back();
      }     
  }
vector<string> letterCombinations(string digits) {
    
    vector<string> ans;
    if(digits.length() == 0){
        return ans;
    }   
     string output = "";
     int index = 0;
     string mapping[10] = {"" , "","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};     
    solve(digits , output , index , ans , mapping);
        return ans;
}
};

139. Word Break
Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.

Note that the same word in the dictionary may be reused multiple times in the segmentation.

 

Example 1:

Input: s = "leetcode", wordDict = ["leet","code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
Example 2:

Input: s = "applepenapple", wordDict = ["apple","pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
Note that you are allowed to reuse a dictionary word.
Example 3:

Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: false
 

Constraints:

1 <= s.length <= 300
1 <= wordDict.length <= 1000
1 <= wordDict[i].length <= 20
s and wordDict[i] consist of only lowercase English letters.
All the strings of wordDict are unique.

solution--
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        int n = s.length();
        vector<bool> dp(n, 0);
        for (int i = -1; i < n; i++) {
            if (i >= 0 && dp[i] == false) {
                continue;
            }
            for (auto word: wordDict) {
                int j = 0;
                while (j < word.length()
                    && i + 1 + j < n
                    && word[j] == s[i + 1 + j]) {
                        j++;
                }
                if (j == word.length()) {
                    dp[i + word.length()] = true;
                }
            }
        }
        return dp[n - 1];
    }
};

95. Unique Binary Search Trees II
Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.

 

Example 1:


Input: n = 3
Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
Example 2:

Input: n = 1
Output: [[1]]
 

Constraints:

1 <= n <= 8

solution--
class Solution {
public:
vector<TreeNode*>ans;
set<vector<int>>st;
vector<int>preo;

// preorder
void traverse(TreeNode*root)
{
   if(root==NULL)
    return;
    preo.push_back(root->val);
    traverse(root->left);
    traverse(root->right);  
}
bool check(TreeNode*ptr)
{
  // return true if it is unique
   vector<int>preorder;
   preo=preorder;//reset the preo since it is global
   traverse(ptr);
   for(int i=0;i<preo.size();i++)
   cout<<preo[i]<<" ";
   cout<<endl;
   if(st.find(preo)==st.end())
   {
     st.insert(preo);
   return true;
   }
   return false;
}

//creating bst

TreeNode*bst(TreeNode*root,int key)
{
    if(root==NULL)
    {
      TreeNode*temp=new TreeNode(key);
     temp->left=NULL;
     temp->right=NULL;
     return temp;
    }

  if(key>root->val)
    root->right=bst(root->right,key);
  else
    root->left=bst(root->left,key);

  return root;
}

void create_bst(vector<int>&nums)
{
TreeNode*root=new TreeNode(nums[0]);//make root
root->left=NULL;
root->right=NULL;

  for(int i=1;i<nums.size();i++)
   root=bst(root,nums[i]);//get always updated root

   if(check(root))
    ans.push_back(root);
}

//make all possible combination..permutation
void func(vector<int>&nums,int index)
{
  if(index==nums.size())
  {
      create_bst(nums);
      return;
  }
  for(int i=index;i<nums.size();i++)
  {
      swap(nums[index],nums[i]);
      func(nums,index+1);
      swap(nums[index],nums[i]);
  }
}
    vector<TreeNode*> generateTrees(int n) {
        vector<int>nums;
        for(int i=1;i<=n;i++)
         nums.push_back(i);
         func(nums,0);
         return ans;
    }
};

/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func dp(l, r int, memo *map[[2]int][]*TreeNode) []*TreeNode {
  /*
  * l: left bound
  * r: right bound
  * memo: memorize the answer of sub problems
  */
  if l > r {
    // no child
    return append(make([]*TreeNode, 0), nil)
  }
  key := [2]int{l, r}
  if v, ok := (*memo)[key]; ok {
    // if this sub-problem has solved
    return v
  }

  // solve
  ret := make([]*TreeNode, 0)
  for i := l; i <= r; i++ { // every number within boundary
    left_part := dp(l, i-1, memo)
    right_part := dp(i+1, r, memo)
    for j := 0; j < len(left_part); j++ {
      for k := 0; k < len(right_part); k++ {
        // traverse all combinations
        root := &TreeNode{
          Val: i, // i is root
          Left: left_part[j],
          Right: right_part[k],
          }
        ret = append(ret, root)
      }
    }
  }
  (*memo)[key] = ret // memorize
  return ret
}

74. Search a 2D Matrix

You are given an m x n integer matrix matrix with the following two properties:

Each row is sorted in non-decreasing order.
The first integer of each row is greater than the last integer of the previous row.
Given an integer target, return true if target is in matrix or false otherwise.

You must write a solution in O(log(m * n)) time complexity.

 

Example 1:


Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true
Example 2:


Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 100
-104 <= matrix[i][j], target <= 104


class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int rows = matrix.size(),
			cols = matrix[0].size(),
            row = 0, col = cols - 1;
			
        while (row < rows && col > -1) {
            int cur = matrix[row][col];
            if (cur == target) return true;
            if (target > cur) row++;
            else col--;
        }
        
        return false;
    }
};

33. Search in Rotated Sorted Array
There is an integer array nums sorted in ascending order (with distinct values).

Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].

Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

You must write an algorithm with O(log n) runtime complexity.

 

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
Example 3:

Input: nums = [1], target = 0
Output: -1
 

Constraints:

1 <= nums.length <= 5000
-104 <= nums[i] <= 104
All values of nums are unique.
nums is an ascending array that is possibly rotated.
-104 <= target <= 104

class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n=nums.size();
        int i, temp;
        int low=0, high=n-1;
        while(low<=high){
            int mid=(low+high)/2;
            if(mid==0 || mid==n-1){
                low=mid;
                break;
            }
            if(nums[mid-1]>nums[mid] && nums[mid+1]>nums[mid]){
                low=mid;
                break;
            }
            else if(nums[mid]>nums[low] && nums[mid]>nums[high]){
                low=mid+1;
            }
            else{
                high=mid-1;
            }
        }
        temp=low;
        low=0, high=n-1;
        if(target==nums[temp]){
            return temp;
        }
        else if(target>nums[high]){
            high=temp-1;
        }
        else if(target<nums[low]){
            low=temp+1;
        }
        while(low<=high){
            int mid=(low+high)/2;
            if(nums[mid]==target){
                return mid;
            }
            else if(target>nums[mid]){
                low=mid+1;
            }
            else{
                high=mid-1;
            }
        }
        return -1;
    }
};

2616. Minimize the Maximum Difference of Pairs
You are given a 0-indexed integer array nums and an integer p. Find p pairs of indices of nums such that the maximum difference amongst all the pairs is minimized. Also, ensure no index appears more than once amongst the p pairs.

Note that for a pair of elements at the index i and j, the difference of this pair is |nums[i] - nums[j]|, where |x| represents the absolute value of x.

Return the minimum maximum difference among all p pairs. We define the maximum of an empty set to be zero.

 

Example 1:

Input: nums = [10,1,2,7,1,3], p = 2
Output: 1
Explanation: The first pair is formed from the indices 1 and 4, and the second pair is formed from the indices 2 and 5. 
The maximum difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1. Therefore, we return 1.
Example 2:

Input: nums = [4,2,1,2], p = 1
Output: 0
Explanation: Let the indices 1 and 3 form a pair. The difference of that pair is |2 - 2| = 0, which is the minimum we can attain.
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 109
0 <= p <= (nums.length)/2

class Solution {
public:
   bool is_possible(int mid, vector<int>&v, int p){

       int cnt = 0;
       int i=0, n = v.size();
       while(i<n and cnt < p){
         if(i+1 < n and v[i+1]-v[i] <= mid)
         { cnt++; 
           i += 2;
         }
         else{
           i++;
         }
       }
       return cnt >= p;
    }
    int minimizeMax(vector<int>& nums, int p) {
        
        int n = nums.size();
        sort(nums.begin(), nums.end());
        int low = 0, high = 1e9, ans = 0;

        while(low<=high){
          int mid =  low+(high-low)/2;

          if(is_possible(mid, nums, p) == true){
            ans = mid;
            high = mid-1;
          }
          else low = mid+1;
        }
        return ans;
    }
};

81. Search in Rotated Sorted Array II
There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).

Before being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].

Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.

You must decrease the overall operation steps as much as possible.

 

Example 1:

Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
Example 2:

Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false
 

Constraints:

1 <= nums.length <= 5000
-104 <= nums[i] <= 104
nums is guaranteed to be rotated at some pivot.
-104 <= target <= 104
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        for(int i=0;i<nums.size();i++){
            if(nums[i]==target){
                return 1;
            }
        }
        return 0;
    }
};


518. Coin Change II
You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.

Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.

You may assume that you have an infinite number of each kind of coin.

The answer is guaranteed to fit into a signed 32-bit integer.

 

Example 1:

Input: amount = 5, coins = [1,2,5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
Example 2:

Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.
Example 3:

Input: amount = 10, coins = [10]
Output: 1
 

Constraints:

1 <= coins.length <= 300
1 <= coins[i] <= 5000
All the values of coins are unique.
0 <= amount <= 5000

class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < coins.size(); i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
};

63. Unique Paths II
You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.

Return the number of possible unique paths that the robot can take to reach the bottom-right corner.

The testcases are generated so that the answer will be less than or equal to 2 * 109.

 

Example 1:


Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
Output: 2
Explanation: There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
Example 2:


Input: obstacleGrid = [[0,1],[0,0]]
Output: 1
 

Constraints:

m == obstacleGrid.length
n == obstacleGrid[i].length
1 <= m, n <= 100
obstacleGrid[i][j] is 0 or 1.

class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
         int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<int>dp(n,-1);
        for(int i =0; i<m;i++){
            vector<int>temp(n,0);
            for(int j =0;j<n;j++){
                int up,left =0;
                if(i>=0 && j>=0 && obstacleGrid[i][j]==1)
                 temp[j] =0;
                else if(i==0 && j==0)
                 temp[j] =1;
                else{
                    if(i>0)
                    up = dp[j];
                    if(j>0)
                    left = temp[j-1];
                    temp[j] = up+left;
                }
            }
            dp = temp;
        }
        return dp[n-1];
    }
};

2369. Check if There is a Valid Partition For The Array
You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.

We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:

The subarray consists of exactly 2 equal elements. For example, the subarray [2,2] is good.
The subarray consists of exactly 3 equal elements. For example, the subarray [4,4,4] is good.
The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.
Return true if the array has at least one valid partition. Otherwise, return false.

 

Example 1:

Input: nums = [4,4,4,5,6]
Output: true
Explanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].
This partition is valid, so we return true.
Example 2:

Input: nums = [1,1,1,2]
Output: false
Explanation: There is no valid partition for this array.
 

Constraints:

2 <= nums.length <= 105
1 <= nums[i] <= 106

class Solution {
private:
    bool solve(vector<int>& nums,int start,int end,vector<int>& dp)
    {
        //Base case
        if(start>end)
            return true;
        else if(end==start)
            return false;
        else if(end-start==1)
            return nums[start]==nums[end];
        
        //If already calculated
        if(dp[start]!=-1)
            return dp[start];

        bool ans=false;
        //If 2 are equal
        if(nums[start]==nums[start+1])
            ans=(ans || (true && solve(nums,start+2,end,dp)));
        //If 3 are equal
        if((nums[start]==nums[start+1])&&(nums[start+1]==nums[start+2]))
            ans=(ans || (true && solve(nums,start+3,end,dp)));
        //If 3 consecutive are increasing elements
        else if((nums[start]==nums[start+1]-1) && (nums[start+1]-1==nums[start+2]-2))
            ans=(ans || (true && solve(nums,start+3,end,dp)));
        
        //Memoize
        return dp[start]=ans;
    }
public:
    bool validPartition(vector<int>& nums) 
    {
        int n=nums.size();
        vector<int> dp(n,-1);
                
        return solve(nums,0,n-1,dp);

    }
};

215. Kth Largest Element in an Array
Given an integer array nums and an integer k, return the kth largest element in the array.

Note that it is the kth largest element in the sorted order, not the kth distinct element.

Can you solve it without sorting?

 

Example 1:

Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
Example 2:

Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
 

Constraints:

1 <= k <= nums.length <= 105
-104 <= nums[i] <= 104

class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        // you can use max heap because of this max heap bydefault sort all the element ub descending order
        
    sort(nums.begin(),nums.end());
    return nums[nums.size()-k];
    }
};

86. Partition List
Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

You should preserve the original relative order of the nodes in each of the two partitions.

 

Example 1:


Input: head = [1,4,3,2,5,2], x = 3
Output: [1,2,2,4,3,5]
Example 2:

Input: head = [2,1], x = 2
Output: [1,2]
 

Constraints:

The number of nodes in the list is in the range [0, 200].
-100 <= Node.val <= 100
-200 <= x <= 200

class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *left = new ListNode(0);
        ListNode *right = new ListNode(0);
        
        ListNode *leftTail = left;
        ListNode *rightTail = right;
        
        while(head != NULL){
            if(head->val < x){
                leftTail->next = head;
                leftTail = leftTail->next;
            }
            else{
                rightTail->next = head;
                rightTail = rightTail->next;
            }
            head = head->next;
        }
        
        leftTail->next = right->next;
        rightTail->next = NULL;
        
        return left->next;
    }
}; 


239. Sliding Window Maximum
You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.

Return the max sliding window.

 

Example 1:

Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
Example 2:

Input: nums = [1], k = 1
Output: [1]
 

Constraints:

1 <= nums.length <= 105
-104 <= nums[i] <= 104
1 <= k <= nums.length

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int i = 0;
        int j = 0;
        int size = nums.size();
        list<int>l;
        vector<int>ans;
        while(j<size){
            while(!l.empty() && l.back()<nums[j]){
                l.pop_back();
            }
            l.push_back(nums[j]);
            if(j-i+1<k){
                j++;
            }
            else if(j-i+1==k){
              ans.push_back(l.front());
              if(l.front()==nums[i]){
                  l.pop_front();
              }
              i++;
              j++;
            }
        }
        return ans;
    }
};


542. 01 Matrix
Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.

The distance between two adjacent cells is 1.

 

Example 1:


Input: mat = [[0,0,0],[0,1,0],[0,0,0]]
Output: [[0,0,0],[0,1,0],[0,0,0]]
Example 2:


Input: mat = [[0,0,0],[0,1,0],[1,1,1]]
Output: [[0,0,0],[0,1,0],[1,2,1]]
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n <= 104
1 <= m * n <= 104
mat[i][j] is either 0 or 1.
There is at least one 0 in mat.

class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>> &mat) {
        int m = mat.size(), n = mat[0].size(), INF = m + n;
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                if (mat[r][c] == 0) continue;
                int top = INF, left = INF;
                if (r - 1 >= 0) top = mat[r - 1][c];
                if (c - 1 >= 0) left = mat[r][c - 1];
                mat[r][c] = min(top, left) + 1;
            }
        }
        for (int r = m - 1; r >= 0; r--) {
            for (int c = n - 1; c >= 0; c--) {
                if (mat[r][c] == 0) continue;
                int bottom = INF, right = INF;
                if (r + 1 < m) bottom = mat[r + 1][c];
                if (c + 1 < n) right = mat[r][c + 1];
                mat[r][c] = min(mat[r][c], min(bottom, right) + 1);
            }
        }
        return mat;
    }
};


1615. Maximal Network Rank
There is an infrastructure of n cities with some number of roads connecting these cities. Each roads[i] = [ai, bi] indicates that there is a bidirectional road between cities ai and bi.

The network rank of two different cities is defined as the total number of directly connected roads to either city. If a road is directly connected to both cities, it is only counted once.

The maximal network rank of the infrastructure is the maximum network rank of all pairs of different cities.

Given the integer n and the array roads, return the maximal network rank of the entire infrastructure.

 

Example 1:



Input: n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]
Output: 4
Explanation: The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once.
Example 2:



Input: n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]
Output: 5
Explanation: There are 5 roads that are connected to cities 1 or 2.
Example 3:

Input: n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]
Output: 5
Explanation: The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected.
 

Constraints:

2 <= n <= 100
0 <= roads.length <= n * (n - 1) / 2
roads[i].length == 2
0 <= ai, bi <= n-1
ai != bi
Each pair of cities has at most one road connecting them.

class Solution {
public:
    int maximalNetworkRank(int n, vector<vector<int>>& roads) {
        vector<unordered_set<int>> graph(n);
        
        // Building the graph (adjacency list). 
        for (const auto& road: roads) {
            graph[road[0]].insert(road[1]);
            graph[road[1]].insert(road[0]);
        }
        
        int maximal = 0;
        for(int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                // Sum of neighbors (connected cities) of both cities. 
                int network_rank = graph[i].size() + graph[j].size();
                
                // Reduce the rank by 1 in case the cities are connected to each other.
                if (graph[j].count(i)) {
                    --network_rank;
                }
                
                // Maximal network rank is the maximum network rank possible.
                maximal = max(maximal, network_rank);
            }
            
        }
        return maximal;
    }
};

class UnionFind {    
    vector<int> parent, rank;
public:
    UnionFind(int n) : parent(n), rank(n, 1) {
        for (int i = 0; i < n; i++) 
            parent[i] = i;
    }

    // Find the root of a given element
    int Find(int x) {
        return (x == parent[x]) ? x : parent[x] = Find(parent[x]);
    }

    // Union of two elements
    void Union(int x, int y) {
        int rootX = Find(x), rootY = Find(y);
        if (rootX == rootY) return;
        if (rank[rootX] > rank[rootY]) swap(rootX, rootY);   
        parent[rootX] = rootY;
        if (rank[rootX] == rank[rootY]) rank[rootY]++;
    }

    // Check if two elements are connected
    bool connected(int x, int y) {
        return Find(x) == Find(y);
    }
};

1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree
Given a weighted undirected connected graph with n vertices numbered from 0 to n - 1, and an array edges where edges[i] = [ai, bi, weighti] represents a bidirectional and weighted edge between nodes ai and bi. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight.

Find all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.

Note that you can return the indices of the edges in any order.

 

Example 1:



Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]
Output: [[0,1],[2,3,4,5]]
Explanation: The figure above describes the graph.
The following figure shows all the possible MSTs:

Notice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.
The edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output.
Example 2:



Input: n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]
Output: [[],[0,1,2,3]]
Explanation: We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical.
 

Constraints:

2 <= n <= 100
1 <= edges.length <= min(200, n * (n - 1) / 2)
edges[i].length == 3
0 <= ai < bi < n
1 <= weighti <= 1000
All pairs (ai, bi) are distinct.

class Solution {
public:
    int e;

    int Kruskal(int n, vector<vector<int>>& edges, vector<int>& MST, int removal = -1, int inclusive = -1) {
        UnionFind uf(n);
        int totalWeight = 0;
        int edgesChosen = 0;

        if (inclusive != -1) {
            auto& edge = edges[inclusive];
            uf.Union(edge[2], edge[3]);
            edgesChosen++;
            totalWeight += edge[0];
            MST.push_back(inclusive);
        }

        for(int i = 0; i < e; i++) {
            auto& edge = edges[i];
            if (i == removal || i == inclusive) continue;
            if (uf.Find(edge[2]) == uf.Find(edge[3])) continue;
            uf.Union(edge[2], edge[3]);
            edgesChosen++;
            totalWeight += edge[0];
            MST.push_back(i);
        }

        return (edgesChosen != n - 1) ? INT_MAX : totalWeight; // Check if disconnected
    }

    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {
        e = edges.size();

        // Reorder edges for sorting
        for(int i = 0; i < e; i++) {
            vector<int>& edge = edges[i];
            vector<int> reorderedEdge = {edge[2], i, edge[0], edge[1]};
            edge = reorderedEdge;
        }

        // Sort edges by weight
        sort(edges.begin(), edges.end());

        vector<int> MST; // Minimal Spanning Tree
        int minWeight = Kruskal(n, edges, MST);

        vector<int> critical;
        vector<bool> isCritical(e, false), isPseudoCritical(e, false);

        // Identify critical and pseudo-critical edges
        for(int j : MST) {
            int edgeIndex = edges[j][1];
            vector<int> mst;
            int withoutEdge = Kruskal(n, edges, mst, j, -1);
            if (minWeight < withoutEdge) {
                critical.push_back(edgeIndex);
                isCritical[edgeIndex] = true;
            } else if (minWeight == withoutEdge) {
                for(int k : mst) isPseudoCritical[edges[k][1]] = true;
            }
        }

        vector<int> pseudoCritical;
        for(int j = 0; j < e; j++) {
            int edgeIndex = edges[j][1];
            int withEdge;
            if (!isPseudoCritical[edgeIndex]) {
                MST.clear();
                withEdge = Kruskal(n, edges, MST, -1, j);
            }
            if ((isPseudoCritical[edgeIndex] || minWeight == withEdge) && !isCritical[edgeIndex]) {
                pseudoCritical.push_back(edgeIndex);
            }
        }

        return {critical, pseudoCritical};
    }
};

168. Excel Sheet Column Title
Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.

For example:

A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
 

Example 1:

Input: columnNumber = 1
Output: "A"
Example 2:

Input: columnNumber = 28
Output: "AB"
Example 3:

Input: columnNumber = 701
Output: "ZY"
 

Constraints:

1 <= columnNumber <= 231 - 1

class Solution {
public:
    string convertToTitle(int columnNumber) {
        string res;
        while(columnNumber > 0){
            columnNumber--;
            int remainder = columnNumber % 26;
            char ch = remainder + 'A';
            res.push_back(ch);
            columnNumber /= 26;
        }
        reverse(begin(res),end(res));
        return res;

    }
};

68. Text Justification
Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left-justified, and no extra space is inserted between words.

Note:

A word is defined as a character sequence consisting of non-space characters only.
Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.
The input array words contains at least one word.
 

Example 1:

Input: words = ["This", "is", "an", "example", "of", "text", "justification."], maxWidth = 16
Output:
[
   "This    is    an",
   "example  of text",
   "justification.  "
]
Example 2:

Input: words = ["What","must","be","acknowledgment","shall","be"], maxWidth = 16
Output:
[
  "What   must   be",
  "acknowledgment  ",
  "shall be        "
]
Explanation: Note that the last line is "shall be    " instead of "shall     be", because the last line must be left-justified instead of fully-justified.
Note that the second line is also left-justified because it contains only one word.
Example 3:

Input: words = ["Science","is","what","we","understand","well","enough","to","explain","to","a","computer.","Art","is","everything","else","we","do"], maxWidth = 20
Output:
[
  "Science  is  what we",
  "understand      well",
  "enough to explain to",
  "a  computer.  Art is",
  "everything  else  we",
  "do                  "
]
 

Constraints:

1 <= words.length <= 300
1 <= words[i].length <= 20
words[i] consists of only English letters and symbols.
1 <= maxWidth <= 100
words[i].length <= maxWidth

class Solution {
public:
    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        vector<string> res;
        const int n = words.size();
        int begin = 0, len = 0;
        for (int i = 0; i < n; ++i) {
            if (len + words[i].size() + (i - begin) > maxWidth) {
                res.emplace_back(connect(words, maxWidth, begin, i, len, false));
                begin = i;
                len = 0;
            }
            len += words[i].size();
        }
        res.emplace_back(connect(words, maxWidth, begin, n, len, true));
        return res;
    }
private:
    string connect(const vector<string>& words, int maxWidth,
                   int begin, int end, int len,
                   bool is_last) {
        string s;
        int n = end - begin;
        for (int i = 0; i < n; ++i) {
            s += words[begin + i];
            addSpaces(i, n - 1, maxWidth - len, is_last, &s);
        }
        if (s.size() < maxWidth) {
            s.append(maxWidth - s.size(), ' ');
        }
        return s;
    }
    void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {
        if (i < spaceCnt) {
            int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);
            s->append(spaces, ' ');
        }
    }
};

97. Interleaving String
Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.

An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:

s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
|n - m| <= 1
The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...
Note: a + b is the concatenation of strings a and b.

 

Example 1:


Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
Output: true
Explanation: One way to obtain s3 is:
Split s1 into s1 = "aa" + "bc" + "c", and s2 into s2 = "dbbc" + "a".
Interleaving the two splits, we get "aa" + "dbbc" + "bc" + "a" + "c" = "aadbbcbcac".
Since s3 can be obtained by interleaving s1 and s2, we return true.
Example 2:

Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
Output: false
Explanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.
Example 3:

Input: s1 = "", s2 = "", s3 = ""
Output: true
 

Constraints:

0 <= s1.length, s2.length <= 100
0 <= s3.length <= 200
s1, s2, and s3 consist of lowercase English letters.
 
class Solution {
public:
    
    bool solve(string s1,string s2, string s3, int i, int j, int k, vector<vector<int>> &dp){
        
        if(dp[i][j]!=-1){
            return dp[i][j];
        }
        
        if(i==s1.length() && j==s2.length() && k==s3.length()){
            return true;
        }
        
        bool x=false,y=false;
        if(i!=s1.length()){
            
            if(s1[i]==s3[k]){
                x=solve(s1, s2, s3, i+1, j, k+1, dp);
            }   
        }
        if(j!=s2.length()){
            
            if(s2[j]==s3[k]){
                y=solve(s1, s2, s3, i, j+1, k+1, dp);
            }   
        }
        
        return dp[i][j]=x||y;
    }
    
    bool isInterleave(string s1, string s2, string s3) {
        int a=s1.length(),b=s2.length();
        vector<vector<int>> dp(a+1,vector<int>(b+1,-1));
        int i=0,j=0,k=0;
        return solve(s1, s2, s3, 0, 0, 0, dp);
        
    }
};

225. Implement Stack using Queues
Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).

Implement the MyStack class:

void push(int x) Pushes element x to the top of the stack.
int pop() Removes the element on the top of the stack and returns it.
int top() Returns the element on the top of the stack.
boolean empty() Returns true if the stack is empty, false otherwise.
Notes:

You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.
Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.
 

Example 1:

Input
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
Output
[null, null, null, 2, 2, false]

Explanation
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // return 2
myStack.pop(); // return 2
myStack.empty(); // return False
 

Constraints:

1 <= x <= 9
At most 100 calls will be made to push, pop, top, and empty.
All the calls to pop and top are valid.
class MyStack {
public:
    queue<int> q1;
    queue<int> q2;
    MyStack() {       
    }    
    void push(int x) {
        while(!q1.empty()){
            int temp = q1.front();
            q1.pop();
            q2.push(temp);
        }
        q1.push(x);
        while(!q2.empty()){
            int temp = q2.front();
            q2.pop();
            q1.push(temp);
        }
    } 
    int pop() {
        int ans = q1.front();
        q1.pop();
        return ans;
    } 
    int top() {
        return q1.front();
    } 
    bool empty() {
        return q1.empty();
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */

2483. Minimum Penalty for a Shop
You are given the customer visit log of a shop represented by a 0-indexed string customers consisting only of characters 'N' and 'Y':

if the ith character is 'Y', it means that customers come at the ith hour
whereas 'N' indicates that no customers come at the ith hour.
If the shop closes at the jth hour (0 <= j <= n), the penalty is calculated as follows:

For every hour when the shop is open and no customers come, the penalty increases by 1.
For every hour when the shop is closed and customers come, the penalty increases by 1.
Return the earliest hour at which the shop must be closed to incur a minimum penalty.

Note that if a shop closes at the jth hour, it means the shop is closed at the hour j.

 

Example 1:

Input: customers = "YYNY"
Output: 2
Explanation: 
- Closing the shop at the 0th hour incurs in 1+1+0+1 = 3 penalty.
- Closing the shop at the 1st hour incurs in 0+1+0+1 = 2 penalty.
- Closing the shop at the 2nd hour incurs in 0+0+0+1 = 1 penalty.
- Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.
- Closing the shop at the 4th hour incurs in 0+0+1+0 = 1 penalty.
Closing the shop at 2nd or 4th hour gives a minimum penalty. Since 2 is earlier, the optimal closing time is 2.
Example 2:

Input: customers = "NNNNN"
Output: 0
Explanation: It is best to close the shop at the 0th hour as no customers arrive.
Example 3:

Input: customers = "YYYY"
Output: 4
Explanation: It is best to close the shop at the 4th hour as customers arrive at each hour.
 

Constraints:

1 <= customers.length <= 105
customers consists only of characters 'Y' and 'N'.

class Solution {
public:
    int bestClosingTime(string customers) {
          int max_score = 0, score = 0, best_hour = -1;
        for(int i = 0; i < customers.size(); ++i) {
            score += (customers[i] == 'Y') ? 1 : -1;
            if(score > max_score) {
                max_score = score;
                best_hour = i;
            }
        }
        return best_hour + 1;
    }
};

1326. Minimum Number of Taps to Open to Water a Garden
There is a one-dimensional garden on the x-axis. The garden starts at the point 0 and ends at the point n. (i.e The length of the garden is n).

There are n + 1 taps located at points [0, 1, ..., n] in the garden.

Given an integer n and an integer array ranges of length n + 1 where ranges[i] (0-indexed) means the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open.

Return the minimum number of taps that should be open to water the whole garden, If the garden cannot be watered return -1.

 

Example 1:


Input: n = 5, ranges = [3,4,1,1,0,0]
Output: 1
Explanation: The tap at point 0 can cover the interval [-3,3]
The tap at point 1 can cover the interval [-3,5]
The tap at point 2 can cover the interval [1,3]
The tap at point 3 can cover the interval [2,4]
The tap at point 4 can cover the interval [4,4]
The tap at point 5 can cover the interval [5,5]
Opening Only the second tap will water the whole garden [0,5]
Example 2:

Input: n = 3, ranges = [0,0,0,0]
Output: -1
Explanation: Even if you activate all the four taps you cannot water the whole garden.
 

Constraints:

1 <= n <= 104
ranges.length == n + 1
0 <= ranges[i] <= 100

class Solution{
public:
    int N;
    long dp[10008];
    long help(int i, vector<pair<int, int>> &vp)
    {
        if (vp[i].second == N)
            return 1;
        if (i == vp.size())
            return INT_MAX;
        if (dp[i] != -1)
            return dp[i];
        long ans = INT_MAX;
        for (int j = i + 1; j < vp.size(); j++)
        {
            if (vp[j].first > vp[i].second)
                break;
            ans = min(ans, 1 + help(j, vp));
        }
        return dp[i] = ans;
    }
    int minTaps(int n, vector<int> &ranges)
    {
        N = n;
        memset(dp, -1, sizeof(dp));
        vector<pair<int, int>> vp;
        for (int i = 0; i < ranges.size(); i++)
        {
            int x = max(0, i - ranges[i]);
            int y = min(n, i + ranges[i]);
            vp.push_back({x, y});
        }
        sort(vp.begin(), vp.end());
        long ans = INT_MAX;
        for (int i = 0; i < n; i++)
        {
            if (vp[i].first == 0)
            {
                ans = min(ans, help(i, vp));
            }
        }
        if (ans == INT_MAX)
            ans = -1;
        return ans;
    }
};

2707. Extra Characters in a String
You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.

Return the minimum number of extra characters left over if you break up s optimally.

 

Example 1:

Input: s = "leetscode", dictionary = ["leet","code","leetcode"]
Output: 1
Explanation: We can break s in two substrings: "leet" from index 0 to 3 and "code" from index 5 to 8. There is only 1 unused character (at index 4), so we return 1.

Example 2:

Input: s = "sayhelloworld", dictionary = ["hello","world"]
Output: 3
Explanation: We can break s in two substrings: "hello" from index 3 to 7 and "world" from index 8 to 12. The characters at indices 0, 1, 2 are not used in any substring and thus are considered as extra characters. Hence, we return 3.
 

Constraints:

1 <= s.length <= 50
1 <= dictionary.length <= 50
1 <= dictionary[i].length <= 50
dictionary[i] and s consists of only lowercase English letters
dictionary contains distinct words

class Solution {
public:
    int minExtraChar(string s, vector<string>& dictionary) {
        int max_val = s.length() + 1;
        vector<int> dp(s.length() + 1, max_val);
        dp[0] = 0;

        unordered_set<string> dictionary_set(dictionary.begin(), dictionary.end());

        for (int i = 1; i <= s.length(); ++i) {
            dp[i] = dp[i - 1] + 1;
            for (int l = 1; l <= i; ++l) {
                if (dictionary_set.find(s.substr(i - l, l)) != dictionary_set.end()) {
                    dp[i] = min(dp[i], dp[i - l]);
                }
            }
        }
        return dp.back();
    }
};

62. Unique Paths
There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.

The test cases are generated so that the answer will be less than or equal to 2 * 109.

 

Example 1:


Input: m = 3, n = 7
Output: 28
Example 2:

Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down
 

Constraints:

1 <= m, n <= 100

class Solution {
public:
    int dp[101][101];
    int solve(int m,int n,int i,int j){
        if(i==m-1||j==n-1){
            return 1;
        }
        if(dp[i][j]!=-1)
            return dp[i][j];
        return dp[i][j]=solve(m,n,i+1,j)+solve(m,n,i,j+1);
    }
    int uniquePaths(int m, int n) {
        memset(dp,-1,sizeof(dp));
        return solve(m,n,0,0);
    }
};

138. Copy List with Random Pointer
A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.

Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.

For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.

Return the head of the copied linked list.

The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:

val: an integer representing Node.val
random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.
Your code will only be given the head of the original linked list.

 

Example 1:


Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]
Example 2:


Input: head = [[1,1],[2,1]]
Output: [[1,1],[2,1]]
Example 3:



Input: head = [[3,null],[3,0],[3,null]]
Output: [[3,null],[3,0],[3,null]]
 

Constraints:

0 <= n <= 1000
-104 <= Node.val <= 104
Node.random is null or is pointing to some node in the linked list.

class Solution {
public:
    Node* copyRandomList(Node* head) {
        unordered_map<Node*,Node*> hashMap;
    Node* temp = head;
//first iteration for inserting deep nodes of every node in the hashmap.
    while(temp != NULL) {
        Node* newNode = new Node(temp->val);
        hashMap[temp] = newNode;
        temp = temp->next;
    }
    Node* t = head;
//second iteration for linking next and random pointer as given question.
    while(t != NULL) {
        Node* node = hashMap[t];
        node->next = (t->next != NULL) ? hashMap[t->next]:NULL;
        node->random = (t->random != NULL) ? hashMap[t->random]:NULL;
        t = t->next;
    }
    return hashMap[head];
    }
};


1647. Minimum Deletions to Make Character Frequencies Unique
A string s is called good if there are no two different characters in s that have the same frequency.

Given a string s, return the minimum number of characters you need to delete to make s good.

The frequency of a character in a string is the number of times it appears in the string. For example, in the string "aab", the frequency of 'a' is 2, while the frequency of 'b' is 1.

 

Example 1:

Input: s = "aab"
Output: 0
Explanation: s is already good.
Example 2:

Input: s = "aaabbbcc"
Output: 2
Explanation: You can delete two 'b's resulting in the good string "aaabcc".
Another way it to delete one 'b' and one 'c' resulting in the good string "aaabbc".
Example 3:

Input: s = "ceabaacb"
Output: 2
Explanation: You can delete both 'c's resulting in the good string "eabaab".
Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).
 

Constraints:

1 <= s.length <= 105
s contains only lowercase English letters.

class Solution {
public:
    int minDeletions(std::string s) {
        std::unordered_map<char, int> cnt;
        int deletions = 0;
        std::unordered_set<int> used_frequencies;
        
        for (char c : s) {
            cnt[c]++;
        }
        
        for (auto& kv : cnt) {
            int freq = kv.second;
            while (freq > 0 && used_frequencies.find(freq) != used_frequencies.end()) {
                freq--;
                deletions++;
            }
            used_frequencies.insert(freq);
        }
        
        return deletions;
    }
};

4. Median of Two Sorted Arrays
Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.

The overall run time complexity should be O(log (m+n)).

 

Example 1:

Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
Example 2:

Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
 

Constraints:

nums1.length == m
nums2.length == n
0 <= m <= 1000
0 <= n <= 1000
1 <= m + n <= 2000
-106 <= nums1[i], nums2[i] <= 106

class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
         
        vector<int>v;
        
        for(auto num:nums1)   
            v.push_back(num);
        
        for(auto num:nums2)  
            v.push_back(num);
        
        sort(v.begin(),v.end());  
        
        int n=v.size();  
        
        return n%2?v[n/2]:(v[n/2-1]+v[n/2])/2.0;
    }
};

905. Sort Array By Parity
Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.

Return any array that satisfies this condition.

 

Example 1:

Input: nums = [3,1,2,4]
Output: [2,4,3,1]
Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.
Example 2:

Input: nums = [0]
Output: [0]
 

Constraints:

1 <= nums.length <= 5000
0 <= nums[i] <= 5000456. 132 Pattern


class Solution {
public:
    vector<int> sortArrayByParity(vector<int>& nums) {
        vector<int> v;
        for(int i=0;i<nums.size();i++){
           if(nums[i]%2==0) v.push_back(nums[i]);
        }
        for(int i=0;i<nums.size();i++){
           if(nums[i]%2!=0) v.push_back(nums[i]);
        }
        return v;
    }
};

456. 132 Pattern
Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].

Return true if there is a 132 pattern in nums, otherwise, return false.

 

Example 1:

Input: nums = [1,2,3,4]
Output: false
Explanation: There is no 132 pattern in the sequence.
Example 2:

Input: nums = [3,1,4,2]
Output: true
Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
Example 3:

Input: nums = [-1,3,2,0]
Output: true
Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
 

Constraints:

n == nums.length
1 <= n <= 2 * 105
-109 <= nums[i] <= 109

class Solution {
public:
    bool find132pattern(vector<int>& nums) {
        
       stack<int> s;
        int third = INT_MIN;

        for (int i = nums.size() - 1; i >= 0; i--) {
            if (nums[i] < third) return true;
            while (!s.empty() && s.top() < nums[i]) {
                third = s.top();
                s.pop();
            }
            s.push(nums[i]);
        }
        return false;
    }
};

229. Majority Element II
Given an integer array of size n, find all elements that appear more than  n/3  times.

 

Example 1:

Input: nums = [3,2,3]
Output: [3]
Example 2:

Input: nums = [1]
Output: [1]
Example 3:

Input: nums = [1,2]
Output: [1,2]
 

Constraints:

1 <= nums.length <= 5 * 104
-109 <= nums[i] <= 109
 class Solution {
public:
    vector<int> majorityElement(vector<int>& v) {
        int n = v.size(); 
    vector<int> ls; 

    for (int i = 0; i < n; i++) {
       
        if (ls.size() == 0 || ls[0] != v[i]) {
            int cnt = 0;
            for (int j = 0; j < n; j++) {
                if (v[j] == v[i]) {
                    cnt++;
                }
            }

            if (cnt > (n / 3))
                ls.push_back(v[i]);
        }

        if (ls.size() == 2) break;
    }

    return ls;
        
    }
};
